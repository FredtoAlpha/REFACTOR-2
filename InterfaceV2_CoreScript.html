<script>
// Scripts principaux extraits de InterfaceV2.html pour am√©liorer la lisibilit√©.
// =======================================================
// FONCTIONS UTILITAIRES GLOBALES (accessibles partout)
// =======================================================

// üîß PROTECTION REALTIME FEEDBACK
window.RealTimeFeedback = window.RealTimeFeedback || null;


// ========== ANCIENNES FONCTIONS MIGR√âES VERS App.* ==========
// Les fonctions suivantes ont √©t√© d√©plac√©es vers l'architecture modulaire :
// - toast() -> App.UI.toast()
// - adjustSimpleNamesFontSize() -> App.UI.adjustSimpleNamesFontSize()
// - isRealClass() -> App.Utils.isRealClass()
// - updateColumnStats() -> App.UI.updateColumnStats()
// - updateAllColumnStats() -> App.UI.updateAllColumnStats()
// - updateAdvancedStats() -> App.Stats.updateAdvancedStats()
// - exportDisposition() -> App.Data.exportDisposition()
// - saveImmediateCache() -> App.Data.saveImmediateCache()
// - updateUndoRedoButtons() -> App.History.updateUndoRedoButtons()
//
// Des wrappers globaux sont disponibles pour compatibilit√© (voir section WRAPPERS ci-dessous)
// undo() et redo() migr√©s vers App.History

// ========== APPELS GOOGLE APPS SCRIPT ==========
// ========== FONCTION AFFICHAGE D'ERREUR UNIVERSELLE ==========
function showErrorState(message, suggestions = []) {
  const board = document.getElementById('board');
  if (!board) {
    console.error('√âl√©ment #board introuvable');
    return;
  }
  
  const defaultSuggestions = [
    'V√©rifiez que vos onglets se terminent par "TEST" (ex: 4¬∞1TEST, 4¬∞2TEST...)',
    'Assurez-vous que vos onglets contiennent des donn√©es avec au moins les colonnes ID et NOM',
    'Cr√©ez un onglet "_STRUCTURE" avec les r√®gles de r√©partition',
    'V√©rifiez la configuration de votre Google Sheet'
  ];
  
  const allSuggestions = suggestions.length > 0 ? suggestions : defaultSuggestions;
  
  board.innerHTML = `
    <div class="col-span-full">
      <div class="error-container">
        <div class="error-icon">
          <i class="fas fa-exclamation-triangle"></i>
        </div>
        <h2 class="error-title">Aucune donn√©e trouv√©e</h2>
        <div class="error-message">
          ${message}
        </div>
        <div class="error-suggestions">
          <h3 class="font-semibold mb-2">Suggestions pour r√©soudre le probl√®me :</h3>
          <ul>
            ${allSuggestions.map(s => `<li>${s}</li>`).join('')}
          </ul>
        </div>
        <div class="mt-4">
          <button onclick="attemptRefresh()" class="btn btn-primary">
            <i class="fas fa-sync"></i> R√©essayer
          </button>
          <button onclick="createDemoStructure()" class="btn btn-secondary ml-3">
            <i class="fas fa-plus"></i> Cr√©er structure exemple
          </button>
        </div>
      </div>
    </div>
  `;
}

// ========== D√âTECTION AUTOMATIQUE DU NIVEAU ==========
function detectNiveau(data) {
  if (!data || data.length === 0) return '';
  
  // Analyser les noms de classes pour d√©tecter le niveau
  const classes = data.map(group => group.classe);
  const niveaux = new Set();
  
  classes.forEach(classe => {
    const match = classe.match(/^(\d¬∞)/);
    if (match) {
      niveaux.add(match[1]);
    }
  });
  
  if (niveaux.size === 1) {
    return Array.from(niveaux)[0];
  } else if (niveaux.size > 1) {
    return `Multi-niveaux (${Array.from(niveaux).join(', ')})`;
  }
  
  return 'Niveau non d√©tect√©';
}

// ========== FONCTION DE TRI DES COLONNES ==========
function sortColumn(classe, sortType, direction = 'asc') {
  const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
  if (!dropZone) return;

  const cards = Array.from(dropZone.querySelectorAll('.student-card'));
  const students = cards.map(card => ({
    card,
    data: STATE.students[card.dataset.id]
  }));

  // facteur : +1 en asc, -1 en desc
  const f = direction === 'asc' ? 1 : -1;

  switch (sortType) {
    /* --- NOM ------------------------------------------------------- */
    case 'name':
      students.sort((a, b) => f * a.data.nom.localeCompare(b.data.nom));
      break;

    /* --- LV2 ------------------------------------------------------- */
    case 'lv2':
      students.sort((a, b) => {
        const ordre = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
        const iA = ordre.indexOf((a.data.lv2 || '').toUpperCase());
        const iB = ordre.indexOf((b.data.lv2 || '').toUpperCase());
        return f * ((iA === -1 ? 999 : iA) - (iB === -1 ? 999 : iB));
      });
      break;

    /* --- OPTION ---------------------------------------------------- */
    case 'option':
      students.sort((a, b) => {
        if (!a.data.opt && !b.data.opt) return 0;
        if (!a.data.opt) return  f;   // ¬´ sans option ¬ª en bas quand asc
        if (!b.data.opt) return -f;
        return f * a.data.opt.localeCompare(b.data.opt);
      });
      break;

    /* --- SCORE COM ---------------------------------------------- */
    case 'score':
      students.sort((a, b) => {
        // Tri par score COM : meilleurs (4=Vert) en haut au premier clic
        const scoreA = a.data.scores.COM || 0;
        const scoreB = b.data.scores.COM || 0;
        return -f * (scoreB - scoreA); // meilleurs en haut en asc
      });
      break;
  }

  /* r√©-injection dans le DOM */
  dropZone.innerHTML = '';
  students.forEach(({ card }) => dropZone.appendChild(card));

  /* m√©morise le dernier tri */
  STATE.sortOrder[classe] = { type: sortType, dir: direction };
}

// ========== FONCTION DE VALIDATION DES MOUVEMENTS ==========
function canMove(eleveId, srcClasse, dstClasse) {
  if (STATE.adminMode || srcClasse === dstClasse) return { ok: true };

  const e = STATE.students[eleveId];
  const dr = STATE.rules[dstClasse] || {};
  const dc = getCurrentClassContent(dstClasse);

  /* üîí FIXE : jamais de d√©placement */
  if (e.mobilite === 'FIXE')
    return { ok:false, reason:`${e.nom} est FIXE dans sa classe` };

  /* üîí PERMUT : BLOQU√â EN DRAG&DROP NORMAL */
  if (e.mobilite === 'PERMUT')
    return { ok:false, reason:`${e.nom} est PERMUT - utilisez le mode SWAP` };

    /* üîí SPEC : m√™me r√®gle que FIXE  (option prioritaire) */
if (e.mobilite === 'SPEC')
  return { ok:false, reason:`${e.nom} est SPEC (option obligatoire)` };

  /* üîí DISSOCIATION : BLOQU√â EN DRAG&DROP NORMAL */
  if (e.disso)
    return { ok:false, reason:`${e.nom} a un code D${e.disso} - utilisez le mode SWAP` };

  /* CAPACIT√â : on avertit mais on autorise */
  if (dr.capacity && dc.length >= dr.capacity) {
    return {
      ok: true,
      warn: `${dstClasse} d√©passe sa capacit√© (${dr.capacity})`
    };
  }

  /* ASSOCIATION */
  if (e.asso) {
    const grp = STATE.aGroups[`A${e.asso}`] || [];
    const encSrc = grp.filter(id => id !== eleveId)
                      .some(id => document.querySelector(`.student-card[data-id="${id}"]`)
                                   ?.closest('.droppable-zone').dataset.classe === srcClasse);
    if (encSrc)
      return { ok:false, reason:`Groupe A${e.asso} doit bouger ensemble (mode Swap ou Admin)` };
  }

  /* V√âRIFIER LV2 et OPTIONS */
  const checkTag = (tag, label) => {
    const tagUp = String(tag || '').trim().toUpperCase();
    if (!tagUp) return true;

    /* LV2 ESP autoris√© partout */
    if (label === 'LV2' && tagUp === 'ESP') return true;

    /* Aucune r√®gle pour la classe ‚ûú tout interdit */
    if (!dr.quotas || Object.keys(dr.quotas).length === 0) {
      return { ok:false, reason:`${label} ${tagUp} interdit dans ${dstClasse} (aucun quota d√©fini)` };
    }

    /* Tag absent dans les quotas ‚ûú interdit */
    if (!(tagUp in dr.quotas)) {
      return { ok:false, reason:`${label} ${tagUp} interdit dans ${dstClasse}` };
    }

    /* Quota √† 0 ‚ûú interdit */
    if (dr.quotas[tagUp] === 0) {
      return { ok:false, reason:`${label} ${tagUp} interdit dans ${dstClasse} (quota 0)` };
    }

    /* √âl√®ves d√©j√† pr√©sents avec ce tag */
    const currentCnt = dc.filter(id => {
      const s = STATE.students[id];
      return s && (String(s.lv2).toUpperCase() === tagUp ||
                   String(s.opt).toUpperCase() === tagUp);
    }).length;

    if (currentCnt >= dr.quotas[tagUp]) {
      return { ok:false, reason:`Quota ${tagUp} atteint (${dr.quotas[tagUp]})` };
    }

    return true;
  };

  const r1 = checkTag(e.lv2, 'LV2');
  if (r1 !== true) return r1;
  console.log(eleveId, e.opt)
  const r2 = checkTag(e.opt, 'Option');
  if (r2 !== true) return r2;

  return { ok:true };
}

// ========== FONCTION UTILITAIRE POUR R√âCUP√âRER LE CONTENU D'UNE CLASSE ==========
function getCurrentClassContent(classe) {
  const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
  if (!dropZone) return [];
  
  return Array.from(dropZone.querySelectorAll('.student-card'))
    .map(card => card.dataset.id);
}

// ========== FONCTIONS DE GESTION DES SWAPS ==========
function canSwap(id1, id2) {
  const card1 = document.querySelector(`.student-card[data-id="${id1}"]`);
  const card2 = document.querySelector(`.student-card[data-id="${id2}"]`);
  
  if (!card1 || !card2) return { ok: false, reason: '√âl√®ve introuvable' };
  
  const classe1 = card1.closest('.droppable-zone').dataset.classe;
  const classe2 = card2.closest('.droppable-zone').dataset.classe;
  
  if (classe1 === classe2) return { ok: false, reason: 'M√™me classe' };
  
  const eleve1 = STATE.students[id1];
  const eleve2 = STATE.students[id2];
  
  // Mode admin : tout est permis
  if (STATE.adminMode) return { ok: true };
  
  // FIXE et SPEC : jamais d√©pla√ßables
  if (eleve1.mobilite === 'FIXE' || eleve2.mobilite === 'FIXE') {
    return { ok: false, reason: 'FIXE ne peut pas bouger' };
  }
  
  if (eleve1.mobilite === 'SPEC' || eleve2.mobilite === 'SPEC') {
    return { ok: false, reason: 'SPEC ne peut pas bouger' };
  }
  
  // M√äME CODE D = SWAP OK
  if (eleve1.disso && eleve2.disso && eleve1.disso === eleve2.disso) {
    return { ok: true };
  }
  
  // PERMUT : v√©rifier compatibilit√©
  if (eleve1.mobilite === 'PERMUT' && eleve2.mobilite === 'PERMUT') {
    const lv1 = (eleve1.lv2 || '').toUpperCase();
    const lv2 = (eleve2.lv2 || '').toUpperCase();
    
    if (lv1 === 'ESP' || lv2 === 'ESP') {
      return { ok: true };
    }
    
    if (lv1 !== lv2) {
      return { ok: false, reason: `PERMUT : LV2 diff√©rentes` };
    }
    
    return { ok: true };
  }
  
  if (eleve1.mobilite === 'PERMUT' || eleve2.mobilite === 'PERMUT') {
    return { ok: false, reason: 'PERMUT ne peut √©changer qu\'avec un autre PERMUT' };
  }
  
  // V√©rifier codes D diff√©rents
  if (eleve1.disso || eleve2.disso) {
    if (eleve1.disso) {
      const dejaPresent = getCurrentClassContent(classe2).some(id => {
        const s = STATE.students[id];
        return s && s.disso === eleve1.disso && id !== id2;
      });
      
      if (dejaPresent) {
        return { ok: false, reason: `Un D${eleve1.disso} est d√©j√† dans ${classe2}` };
      }
    }
    
    if (eleve2.disso) {
      const dejaPresent = getCurrentClassContent(classe1).some(id => {
        const s = STATE.students[id];
        return s && s.disso === eleve2.disso && id !== id1;
      });
      
      if (dejaPresent) {
        return { ok: false, reason: `Un D${eleve2.disso} est d√©j√† dans ${classe1}` };
      }
    }
  }
  
  // V√©rifier les quotas basiques
  const dr1 = STATE.rules[classe2] || {};
  const dr2 = STATE.rules[classe1] || {};
  
  if (eleve1.lv2 && eleve1.lv2.toUpperCase() !== 'ESP') {
    if (!dr1.quotas || dr1.quotas[eleve1.lv2.toUpperCase()] === 0) {
      return { ok: false, reason: `${eleve1.lv2} interdit dans ${classe2}` };
    }
  }
  
  if (eleve2.lv2 && eleve2.lv2.toUpperCase() !== 'ESP') {
    if (!dr2.quotas || dr2.quotas[eleve2.lv2.toUpperCase()] === 0) {
      return { ok: false, reason: `${eleve2.lv2} interdit dans ${classe1}` };
    }
  }
  
  return { ok: true };
}

function performSwap(id1, id2) {
  const card1 = document.querySelector(`.student-card[data-id="${id1}"]`);
  const card2 = document.querySelector(`.student-card[data-id="${id2}"]`);
  
  if (!card1 || !card2) return;
  
  const zone1 = card1.closest('.droppable-zone');
  const zone2 = card2.closest('.droppable-zone');
  
  if (!zone1 || !zone2) return;
  
  // Animation de swap
  card1.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
  card2.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
  
  // √âchanger les cartes
  zone2.appendChild(card1);
  zone1.appendChild(card2);
  
  // Historique
  const swapAction = {
    type: 'swap',
    id1, id2,
    eleve1Name: STATE.students[id1]?.nom || '√âl√®ve 1',
    eleve2Name: STATE.students[id2]?.nom || '√âl√®ve 2',
    classe1: zone1.dataset.classe,
    classe2: zone2.dataset.classe,
    timestamp: new Date().toISOString()
  };
  STATE.history.push(swapAction);
  STATE.historyTimeline.push(swapAction);
  STATE.future = [];
  updateUndoRedoButtons();
  
  // Mettre √† jour le panneau historique
  updateHistoryPanel();
  
  // ‚úÖ UNE SEULE mise √† jour des colonnes
  updateAllColumnStats();
  
  // ‚úÖ UNE SEULE mise √† jour des stats avanc√©es avec d√©lai
  setTimeout(() => updateAdvancedStats(), 150);
  
  // Feedback temps r√©el
if (window.RealTimeFeedback) {
  window.RealTimeFeedback.updateMetrics();
}
  
  // Sauvegarde
  if (STATE.currentMode === 'CACHE') {
    setTimeout(() => saveImmediateCache(), 200);
  }
  
  const eleve1 = STATE.students[id1];
  const eleve2 = STATE.students[id2];
  toast(`Swap r√©ussi entre ${eleve1.nom} et ${eleve2.nom}`, 'success');
}

function handleCardClick(e) {
  if (!STATE.swapMode) return;
  
  const card = e.currentTarget;
  const eleveId = card.dataset.id;
  const eleve = STATE.students[eleveId];
  
  // Premi√®re s√©lection
  if (!STATE.swapFirst) {
    STATE.swapFirst = eleveId;
    card.classList.add('swap-mode');
    
    let msg = `${eleve.nom} s√©lectionn√©`;
    if (eleve.mobilite === 'PERMUT') msg += ' (PERMUT)';
    else if (eleve.disso) msg += ` (D${eleve.disso})`;
    msg += ' ‚Äì choisissez un √©l√®ve √† √©changer';
    toast(msg, 'info');
    
    // Mettre en √©vidence les autres colonnes
    document.querySelectorAll('.droppable-zone').forEach(zone => {
      if (zone.dataset.classe !== card.closest('.droppable-zone').dataset.classe) {
        zone.classList.add('swap-target');
      }
    });
    return;
  }
  
  // Deuxi√®me s√©lection
  const firstId = STATE.swapFirst;
  const firstCard = document.querySelector(`.student-card[data-id="${firstId}"]`);
  
  // M√™me √©l√®ve : annuler
  if (eleveId === firstId) {
    firstCard.classList.remove('swap-mode');
    document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
    STATE.swapFirst = null;
    return;
  }
  
  // V√©rifier et effectuer le swap
  const check = canSwap(firstId, eleveId);
  if (check.ok) {
    performSwap(firstId, eleveId);
  } else {
    toast(check.reason, 'error');
  }
  
  // Nettoyer l'√©tat
  firstCard.classList.remove('swap-mode');
  document.querySelectorAll('.student-card').forEach(c => c.classList.remove('swap-mode'));
  document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
  STATE.swapFirst = null;
}

// ========== FONCTION HELPER POUR SIMPLIFIER LES NOMS COMPOS√âS ========== 
// VERSION 4.2 - Octobre 2025 - InterfaceV2
// Logique de simplification affin√©e selon les cas r√©els
console.log('üîÑ VERSION 4.2 - Fonction simplifierNomComplet am√©lior√©e charg√©e dans InterfaceV2');

function simplifierNomComplet(nom, prenom) {
  // VERSION 4.2 - Logique compl√®te de simplification
  if (!nom && !prenom) return '';

  nom = (nom || '').trim().replace(/\s+/g, ' ');
  prenom = (prenom || '').trim().replace(/\s+/g, ' ');

  const nomParts = nom.split(/[\s-]+/).filter(Boolean); // Split by space or hyphen, filter out empty strings
  const prenomParts = prenom.split(/[\s-]+/).filter(Boolean); // Filter out empty strings

  const nomPart1 = nomParts[0] || '';
  const nomPart2 = nomParts[1] || '';
  const prenomPart1 = prenomParts[0] || '';

  let finalNom = nomPart1;
  let finalPrenom = '';

  if (prenomPart1) {
    finalPrenom = prenomPart1;
  } else if (nomPart2) {
    // Si pas de pr√©nom fourni, utiliser la deuxi√®me partie du nom comme pr√©nom
    finalPrenom = nomPart2;
  }

  let resultat = `${finalNom} ${finalPrenom}`.trim();

  const MAX_LENGTH = 25;
  if (resultat.length > MAX_LENGTH) {
    const nomPart = finalNom;
    const prenomPart = finalPrenom;

    const availableForPrenom = MAX_LENGTH - nomPart.length - 1;

    if (availableForPrenom > 0) {
      const truncatedPrenom = prenomPart.substring(0, availableForPrenom - 1) + '.';
      resultat = `${nomPart} ${truncatedPrenom}`.trim();
    } else {
      resultat = nomPart.substring(0, MAX_LENGTH - 1) + '.';
    }
  }

  console.log(`DEBUG_SIMPLIFIER: nom="${nom}", prenom="${prenom}"`);
  console.log(`DEBUG_SIMPLIFIER: nomParts="${nomParts.join(',')}", prenomParts="${prenomParts.join(',')}"`);
  console.log(`DEBUG_SIMPLIFIER: nomPart1="${nomPart1}", nomPart2="${nomPart2}", prenomPart1="${prenomPart1}"`);
  console.log(`DEBUG_SIMPLIFIER: finalNom="${finalNom}", finalPrenom="${finalPrenom}"`);
  console.log(`DEBUG_SIMPLIFIER: resultat avant finalisation="${resultat}"`);

  if (nom !== finalNom || prenom !== finalPrenom || resultat.length > MAX_LENGTH) {
    console.log(`‚úÇÔ∏è InterfaceV2 v4.2 - Nom simplifi√©: "${nom} ${prenom}" ‚Üí "${resultat}" (${resultat.length} car.)`);
  }

  return resultat;
}

// Marquer la version pour √©viter les conflits
simplifierNomComplet.version = '4.0';

// Exposer sur window pour accessibilit√© globale
if (typeof window !== 'undefined') {
  window.simplifierNomComplet = simplifierNomComplet;
  console.log('‚úÖ simplifierNomComplet VERSION 4.0 expos√©e globalement depuis InterfaceV2');
}

// ========== FONCTION DE CR√âATION DES CARTES √âL√àVES ==========
function createStudentCard(eleve) {
  /* --- STOP "CARTE VIDE" : on ignore les enregistrements sans id --- */
  if (!eleve || !eleve.id || !eleve.id.trim()) return null;
  /* ---------------------------------------------------------------- */

  const template = document.querySelector('#tpl-carte-eleve');
  const card = template.content.cloneNode(true).children[0];

  card.dataset.id = eleve.id;
  card.classList.add(`sexe-${eleve.sexe}`);

  // Attributs ARIA pour la carte √©l√®ve
  const nomCompletAria = eleve.prenom ? `${eleve.nom} ${eleve.prenom}` : eleve.nom;
  card.setAttribute('role', 'listitem');
  card.setAttribute('aria-label', nomCompletAria);
  card.setAttribute('aria-grabbed', 'false');

  // ========== MODE SIMPLE : FOND BLANC + POLICE COULEUR SEXE + SOULIGNE ROUGE SI COM=1 ==========
  if (STATE.viewMode === 'simple') {
    card.classList.add('simple-mode');
    card.innerHTML = `<div class="simple-line">
      <span class="student-simple-name"></span>
    </div>`;
    const nameEl = card.querySelector('.student-simple-name');

    // Nom complet simplifi√©
    let nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);

    // Couleur de police selon sexe
    let couleurTexte = '#333'; // Gris fonc√© par d√©faut
    if (eleve.sexe === 'F') {
      couleurTexte = '#ec4899'; // Rose pour F
    } else if (eleve.sexe === 'M') {
      couleurTexte = '#3b82f6'; // Bleu pour M
    }

    // Soulign√© rouge si score COM = 1
    let soulignement = 'none';
    let couleurSoulignement = '';
    if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
      soulignement = 'underline';
      couleurSoulignement = '#FF0000'; // Rouge
    }

    // Appliquer les styles
    nameEl.textContent = nomComplet;
    nameEl.style.display = 'block';
    nameEl.style.textAlign = 'center';
    nameEl.style.fontSize = '1.1rem';
    nameEl.style.fontWeight = '600';
    nameEl.style.padding = '8px';
    nameEl.style.color = couleurTexte;
    nameEl.style.textDecoration = soulignement;
    nameEl.style.overflow = 'hidden';
    nameEl.style.textOverflow = 'ellipsis';
    nameEl.style.whiteSpace = 'nowrap';
    nameEl.style.maxWidth = '100%';
    if (soulignement === 'underline') {
      nameEl.style.textDecorationColor = couleurSoulignement;
      nameEl.style.textDecorationThickness = '3px';
      nameEl.style.textUnderlineOffset = '3px';
    }

    card.style.background = '#fff'; // Fond blanc pour tous
    card.style.border = '1px solid rgba(0,0,0,0.1)';
    card.style.borderRadius = '6px';
  } else if (STATE.viewMode === 'essential') {
    // Mode essentiel : nom + badges essentiels (pas d'options ni scores)
    const fullNameElement = card.querySelector('.student-fullname');
    const nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);
    fullNameElement.textContent = nomComplet;

    // NOM EN ROUGE si score COM = 1
    if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
      fullNameElement.style.color = '#FF0000';
      fullNameElement.style.fontWeight = '700';
    }

    // Badges essentiels : LV2, OPT, DISSO, ASSO (PAS DE DISPO)
    const allBadgesContainer = card.querySelector('.all-badges');
    allBadgesContainer.style.justifyContent = 'center';

    let totalBadges = 0;
    if (eleve.mobilite && eleve.mobilite !== 'LIBRE') totalBadges++;
    if (eleve.disso) totalBadges++;
    if (eleve.asso) totalBadges++;
    if (eleve.lv2) totalBadges++;
    const compactMode = totalBadges > 3;

    // Badge Mobilit√©
    if (eleve.mobilite && eleve.mobilite !== 'LIBRE') {
      const badge = document.createElement('span');
      let mobText = eleve.mobilite;
      let mobClass = 'badge-mobilite';
      if (compactMode) {
        const abrevMap = {'CONDI': 'CO', 'FIXE': 'FI', 'PERMUT': 'PER', 'SPEC': 'SP'};
        mobText = abrevMap[eleve.mobilite] || eleve.mobilite;
        mobClass += ' badge-compact';
      }
      badge.className = `mini-badge ${mobClass}`;
      badge.textContent = mobText;
      badge.title = `Mobilit√©: ${eleve.mobilite}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Dissociation
    if (eleve.disso) {
      const badge = document.createElement('span');
      badge.className = 'mini-badge badge-disso';
      badge.textContent = eleve.disso.replace(/^D/i, 'D');
      badge.title = `Dissociation: ${eleve.disso}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Association
    if (eleve.asso) {
      const badge = document.createElement('span');
      badge.className = 'mini-badge badge-asso';
      badge.textContent = eleve.asso.replace(/^A/i, 'A');
      badge.title = `Association: ${eleve.asso}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge LV2
    if (eleve.lv2 && eleve.lv2.trim()) {
      const badge = document.createElement('span');
      badge.className = `mini-badge badge-${eleve.lv2.toUpperCase()}`;
      badge.textContent = eleve.lv2.toUpperCase();
      badge.title = `LV2: ${eleve.lv2}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge OPT
    if (eleve.opt && eleve.opt.trim()) {
      const badge = document.createElement('span');
      badge.className = `mini-badge badge-${eleve.opt.toUpperCase()}`;
      badge.textContent = eleve.opt.toUpperCase();
      badge.title = `Option: ${eleve.opt}`;
      allBadgesContainer.appendChild(badge);
    }

    // Source uniquement (pas de scores)
    card.querySelector('.source-class').textContent = eleve.source || '';
    card.querySelector('.scores').innerHTML = '';
  } else {
    // ========== MODE COMPLETE: NOM + LV2/OPT + BADGES SCORES ==========
    const fullNameElement = card.querySelector('.student-fullname');
    const nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);
    fullNameElement.textContent = nomComplet;
    fullNameElement.className = 'student-fullname';

    // NOM EN ROUGE si score COM = 1
    if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
      fullNameElement.style.color = '#FF0000';
      fullNameElement.style.fontWeight = '700';
    }
    
    // Badge DISPO (nom complet)
    const dispoContainer = card.querySelector('.badge-dispo-container');
    if (eleve.dispo && eleve.dispo.trim()) {
      const dispoBadge = document.createElement('span');
      dispoBadge.className = 'badge-dispo';
      const dispoValue = eleve.dispo.toUpperCase().trim();
      dispoBadge.textContent = dispoValue; // Afficher le nom complet
      dispoBadge.title = `Dispositif: ${eleve.dispo}`;
      dispoContainer.appendChild(dispoBadge);
    }

    // ========== LIGNE 2: TOUS LES BADGES (LV2, OPT, DISSO, ASSO) ==========
    const allBadgesContainer = card.querySelector('.all-badges');
    allBadgesContainer.style.justifyContent = 'center';

    // Badge LV2
    if (eleve.lv2 && eleve.lv2.trim()) {
      const badge = document.createElement('span');
      badge.className = `mini-badge badge-${eleve.lv2.toUpperCase()}`;
      badge.textContent = eleve.lv2.toUpperCase();
      badge.title = `LV2: ${eleve.lv2}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Option
    if (eleve.opt && eleve.opt.trim()) {
      const badge = document.createElement('span');
      badge.className = `mini-badge badge-${eleve.opt.toUpperCase()}`;
      badge.textContent = eleve.opt.toUpperCase();
      badge.title = `Option: ${eleve.opt}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Dissociation
    if (eleve.disso) {
      const badge = document.createElement('span');
      badge.className = 'mini-badge badge-disso';
      badge.textContent = eleve.disso.replace(/^D/i, 'D');
      badge.title = `Dissociation: ${eleve.disso}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Association
    if (eleve.asso) {
      const badge = document.createElement('span');
      badge.className = 'mini-badge badge-asso';
      badge.textContent = eleve.asso.replace(/^A/i, 'A');
      badge.title = `Association: ${eleve.asso}`;
      allBadgesContainer.appendChild(badge);
    }
    
    // ========== LIGNE 3: Source + Scores ==========
    card.querySelector('.source-class').textContent = eleve.source || '';
    
    // Badges scores COM/TRA/PART/ABS avec lettres et couleurs
    const scoresContainer = card.querySelector('.scores');
    const scoreMap = [
      { key: 'COM', label: 'Comportement', letter: 'C' },
      { key: 'TRA', label: 'Travail', letter: 'T' },
      { key: 'PART', label: 'Participation', letter: 'P' },
      { key: 'ABS', label: 'Absences', letter: 'A' }
    ];
    scoreMap.forEach(({ key, label, letter }) => {
      const value = eleve.scores[key];
      if (value && value > 0) {
        const pill = document.createElement('div');
        pill.className = `score-pill score-${value}`;
        pill.textContent = letter; // Afficher la LETTRE (C, T, P, A)
        pill.title = `${label}: ${value}/4`;
        scoresContainer.appendChild(pill);
      }
    });
  }
  
  // Event listeners pour drag & drop et swap
  card.addEventListener('dragstart', handleDragStart);
  card.addEventListener('dragend', handleDragEnd);
  card.addEventListener('click', handleCardClick);
  
  return card;
}

// ========== FONCTION DE CR√âATION DES COLONNES DE CLASSE ==========
function createClassColumn(classe, eleves) {
  // On retire d'embl√©e les enregistrements "vides"
  const clean = eleves.filter(e => e && e.id && e.id.trim());

  const column = document.querySelector('#tpl-classe-col')
                 .content.cloneNode(true).children[0];

  // Attributs ARIA pour la colonne
  const classHeader = column.querySelector('.class-header');
  if (classHeader) {
    classHeader.id = `class-header-${classe}`;
  }
  column.setAttribute('role', 'region');
  column.setAttribute('aria-labelledby', `class-header-${classe}`);

  column.querySelector('.classe-name').textContent = classe;
  column.querySelector('.count').textContent   = clean.length;
  column.querySelector('.count-f').textContent = clean.filter(e => e.sexe === 'F').length;
  column.querySelector('.count-m').textContent = clean.filter(e => e.sexe === 'M').length;

  const dropZone = column.querySelector('.droppable-zone');
  dropZone.dataset.classe = classe;
  dropZone.setAttribute('role', 'list');
  dropZone.setAttribute('aria-label', `Liste des √©l√®ves de ${classe}`);

  // Boutons de tri
  column.querySelectorAll('.sort-btn').forEach(btn => {
    btn.addEventListener('click', e => {
      const sortType = e.currentTarget.dataset.sort;
      const prev     = STATE.sortOrder[classe] || {};
      const dir      = (prev.type === sortType && prev.dir === 'asc') ? 'desc' : 'asc';

      sortColumn(classe, sortType, dir);

      // Feedback visuel
      column.querySelectorAll('.sort-btn').forEach(b => {
        const arrow = b.querySelector('.sort-arrow');
        if (b === e.currentTarget) {
          b.classList.add('active');
          arrow.textContent = dir === 'asc' ? '‚Üë' : '‚Üì';
        } else {
          b.classList.remove('active');
          arrow.textContent = '‚áÖ';
        }
      });
    });
  });

  // Restaurer l'√©tat visuel du tri si existant
  const currentSort = STATE.sortOrder[classe];
  if (currentSort) {
    column.querySelectorAll('.sort-btn').forEach(btn => {
      const arrow = btn.querySelector('.sort-arrow');
      if (btn.dataset.sort === currentSort.type) {
        btn.classList.add('active');
        arrow.textContent = currentSort.dir === 'asc' ? '‚Üë' : '‚Üì';
      }
    });
  }

  // Drag-and-drop
  dropZone.addEventListener('dragover',  handleDragOver);
  dropZone.addEventListener('drop',      handleDrop);
  dropZone.addEventListener('dragleave', handleDragLeave);

  const sortable = new Sortable(dropZone, {
    group: 'students',
    animation: 150,
    ghostClass: 'opacity-50',
    dragClass: 'dragging',
    onEnd: handleSortEnd,
    onStart: (evt) => {
      console.log('üñ±Ô∏è Drag started:', evt.item.dataset.id);
      // Stocker l'√©l√©ment en cours de d√©placement
      STATE.draggingElement = evt.item;
      STATE.dragStartZone = evt.from;
    },
    onMove: (evt) => {
      console.log('üñ±Ô∏è Drag move:', evt.dragged.dataset.id, 'from', evt.from.dataset.classe, 'to', evt.to.dataset.classe);
    }
  });
  
  // (SUPPRIM√â : double appel de handleSortEnd - onEnd de SortableJS suffit)
  
  console.log('üîß Sortable cr√©√© pour zone:', dropZone.dataset.classe);

  // Cartes √©l√®ves
  clean.forEach(e => {
    const c = createStudentCard(e);
    if (c) dropZone.appendChild(c);
  });

  // Adaptation dynamique de la taille des noms en vue simplifi√©e
  setTimeout(() => adjustSimpleNamesFontSize(dropZone), 0);
  return column;
}

// ========== HANDLERS DRAG & DROP ==========
function handleDragStart(e) {
  if (STATE.swapMode) return; // Pas de drag en mode swap

  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', e.target.dataset.id);
  // Mettre √† jour aria-grabbed
  e.target.setAttribute('aria-grabbed', 'true');
  e.target.classList.add('dragging');
}

function handleDragEnd(e) {
  e.target.classList.remove('dragging');
  // Remettre aria-grabbed √† false
  e.target.setAttribute('aria-grabbed', 'false');
  document.querySelectorAll('.drag-over, .drop-forbidden').forEach(el => {
    el.classList.remove('drag-over', 'drop-forbidden');
  });
}

function handleDragOver(e) {
  if (STATE.swapMode) return;
  e.preventDefault();
  
  // V√©rifier si le drop est autoris√©
  const draggedId = e.dataTransfer.getData('text/plain') || 
    document.querySelector('.dragging')?.dataset.id;
  
  if (draggedId) {
    const draggedCard = document.querySelector(`.student-card[data-id="${draggedId}"]`);
    if (draggedCard) {
      const srcClasse = draggedCard.closest('.droppable-zone').dataset.classe;
      const dstClasse = e.currentTarget.dataset.classe;
      
      const check = canMove(draggedId, srcClasse, dstClasse);
      
      if (check.ok || STATE.adminMode) {
        e.currentTarget.classList.add('drag-over');
        e.currentTarget.classList.remove('drop-forbidden');
        
        // Pr√©visualiser l'impact du d√©placement
        if (window.RealTimeFeedback && srcClasse !== dstClasse) {
  window.RealTimeFeedback.previewMove(draggedId, dstClasse);
}
      } else {
        e.currentTarget.classList.add('drop-forbidden');
        e.currentTarget.classList.remove('drag-over');
        
        // R√©initialiser les changements si drop interdit
        if (window.RealTimeFeedback) {
  window.RealTimeFeedback.resetChanges();
        }
      }
    }
  }
}

function handleDragLeave(e) {
  if (e.target === e.currentTarget) {
    e.currentTarget.classList.remove('drag-over', 'drop-forbidden');
    
    // R√©initialiser les changements quand on quitte la zone
    if (RealTimeFeedback) {
      RealTimeFeedback.resetChanges();
    }
  }
}

function handleDrop(e) {
  if (STATE.swapMode) return;
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over', 'drop-forbidden');
}

// ========== handleSortEnd (version finale en bas du fichier, suppression de l'ancienne version) ==========
window.handleSortEnd = function(evt) {
  console.log('üéØ handleSortEnd CLEAN');
  
  if (STATE.swapMode) return;

  const eleveId = evt.item.dataset.id;
  const oldClasse = evt.from.dataset.classe;
  const newClasse = evt.to.dataset.classe;

  // Si m√™me classe, juste mise √† jour des colonnes
  if (oldClasse === newClasse) {
    updateAllColumnStats(); // ‚Üê CET APPEL MANQUE PEUT-√äTRE
    if (window.RealTimeFeedback) window.RealTimeFeedback.updateMetrics();
    return;
  }

  const check = canMove(eleveId, oldClasse, newClasse);

  if (!check.ok && !STATE.adminMode) {
    evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex] || null);
    toast(check.reason, 'error');
    updateAllColumnStats(); // ‚Üê CET APPEL MANQUE PEUT-√äTRE
    return;
  }

  if (check.warn && !STATE.adminMode) {
    toast(check.warn, 'warning');
  }

  // Historique
  const moveAction = {
    type: 'move', 
    eleveId, 
    eleveName: STATE.students[eleveId]?.nom || '√âl√®ve',
    oldClasse, 
    newClasse,
    oldIndex: evt.oldIndex, 
    newIndex: evt.newIndex,
    timestamp: new Date().toISOString()
  };
  STATE.history.push(moveAction);
  STATE.historyTimeline.push(moveAction);
  STATE.future = [];
  updateUndoRedoButtons();
  
  // Mettre √† jour le panneau historique
  updateHistoryPanel();

  // ‚úÖ UNE SEULE mise √† jour des colonnes
  updateAllColumnStats(); // ‚Üê CET APPEL DOIT √äTRE PR√âSENT
  
  // ‚úÖ UNE SEULE mise √† jour des stats avanc√©es avec d√©lai
  setTimeout(() => updateAdvancedStats(), 150);
  
  // Feedback temps r√©el
  if (RealTimeFeedback) RealTimeFeedback.updateMetrics();
  
  // Sauvegarde
  if (STATE.currentMode === 'CACHE') {
    setTimeout(() => saveImmediateCache(), 200);
  }
};

// ========== FONCTION MANQUANTE - Chargement des donn√©es selon le mode ==========
// ========== FONCTION - Affichage des colonnes/classes ==========
function renderBoard(data) {
  const board = document.getElementById('board');
  if (!board) {
    console.error('√âl√©ment #board introuvable');
    return;
  }

  board.innerHTML = '';
  if (!data || data.length === 0) {
    showErrorState('Aucune classe trouv√©e');
    return;
  }

  /* --- tri naturel des intitul√©s "6¬∞1", "6¬∞2", ‚Ä¶ --- */
  const sortedData = data.slice().sort((a, b) => {
    const ma = a.classe.match(/(\d+)¬∞(\d+)/);
    const mb = b.classe.match(/(\d+)¬∞(\d+)/);
    if (ma && mb) {
      const nivA = +ma[1], nivB = +mb[1];
      if (nivA !== nivB) return nivA - nivB;
      return +ma[2] - +mb[2];
    }
    return a.classe.localeCompare(b.classe);
  });

  /* --- cr√©ation des colonnes --- */
  sortedData.forEach(group => {
    const col = createClassColumn(group.classe, group.eleves);
    if (col) board.appendChild(col);
  });

  /* --- ajustements de pr√©sentation --- */
  setTimeout(resizeCards, 100);
  updateAllColumnStats();              // <-- nouvelle ligne : compteurs √† jour !

  if (STATE.viewMode === 'simple') {
    setTimeout(() => {
      document.querySelectorAll('.droppable-zone')
              .forEach(zone => adjustSimpleNamesFontSize(zone));
    }, 120);
  }

  if (window.applyLisibilitePreferences) {
    window.applyLisibilitePreferences();
  }

  /* --- initialisation des graphiques --- */
  setTimeout(() => {
    if (typeof initCharts === 'function') {
      initCharts();
      console.log('üìä Graphiques initialis√©s apr√®s chargement des donn√©es');
    }
  }, 200);
}

// ========== FONCTION MANQUANTE - AFFICHAGE DU BADGE DE MODE ==========
function showModeBadge(mode) {
  const badge = document.getElementById('modeBadge');
  if (badge) {
    // D√©terminer le label et la couleur selon le mode
    let label = 'MODE ' + mode;
    let bgColor = '#3b82f6'; // Bleu par d√©faut

    switch(mode) {
      case 'TEST':
        label = 'üìö TEST (Classes test)';
        bgColor = '#3b82f6'; // Bleu
        break;
      case 'PREVIOUS':
        label = 'üìã PREVIOUS (Ann√©e pass√©e)';
        bgColor = '#8b5cf6'; // Violet
        break;
      case 'FINAL':
        label = '‚úÖ FINAL (Classes finales)';
        bgColor = '#10b981'; // Vert
        break;
      // Anciens modes pour r√©trocompatibilit√©
      case 'CACHE':
        label = 'MODE CACHE';
        bgColor = '#f59e0b'; // Orange
        break;
      case 'INT':
        label = 'MODE INT';
        bgColor = '#10b981'; // Vert
        break;
    }

    badge.textContent = label;
    badge.style.background = bgColor;
    badge.style.color = 'white';
    badge.classList.remove('hidden');
  }
}

// ========== FONCTIONS MANQUANTES - Auto-save ==========
function startAutoSave() {
  stopAutoSave(); // ‚Üê On s'assure qu'il n'y en a qu'un
  console.log('üîÑ Auto-save CACHE activ√© (1 minute)');
  autoSaveInterval = setInterval(async () => {
    const disposition = exportDisposition();
    const cacheData = {
      date: new Date().toISOString(),
      disposition: disposition,
      mode: STATE.currentMode
    };

    // Sauvegarde locale dans le navigateur
    localStorage.setItem('cache-data', JSON.stringify(cacheData));
    console.log('üíæ Auto-save LOCAL effectu√©');

    // Sauvegarde distante dans le backend (PropertiesService + onglets CACHE)
    if (typeof gsRun === 'function') {
      try {
        const result = await gsRun('saveCacheData', cacheData);
        if (result && result.success) {
          console.log('üíæ Auto-save BACKEND r√©ussi');
        } else {
          console.warn('‚ö†Ô∏è Auto-save BACKEND √©chou√©:', result?.error);
        }
      } catch (error) {
        console.error('‚ùå Erreur auto-save BACKEND:', error);
      }
    }
  }, 60000); // Toutes les 1 minute
}

function stopAutoSave() {
  if (autoSaveInterval !== null) { // ‚Üê V√©rifie l'existence
    clearInterval(autoSaveInterval);
    autoSaveInterval = null;
    console.log('‚èπÔ∏è Auto-save arr√™t√©');
  }
}

// ========== FONCTION MANQUANTE - V√©rifier le cache ==========
async function checkCache() {
  const restoreBlock = document.getElementById('restoreCacheBlock');
  const lastDate = document.getElementById('lastCacheDate');

  // 1. V√©rifier d'abord le localStorage
  const cached = localStorage.getItem('cache-data');
  if (cached) {
    try {
      const data = JSON.parse(cached);
      if (restoreBlock) restoreBlock.classList.remove('hidden');
      if (lastDate) {
        lastDate.textContent = new Date(data.date).toLocaleString('fr-FR');
      }
      return; // On a trouv√© des donn√©es dans le localStorage
    } catch (e) {
      console.error('Cache localStorage invalide:', e);
    }
  }

  // 2. Si pas de localStorage, v√©rifier le backend (PropertiesService)
  try {
    console.log('üîç V√©rification de la sauvegarde automatique depuis le backend...');
    const backendCache = await gsRun('getLastCacheInfo');

    if (backendCache && backendCache.exists && backendCache.date) {
      console.log('‚úÖ Sauvegarde automatique trouv√©e dans le backend:', backendCache);
      if (restoreBlock) restoreBlock.classList.remove('hidden');
      if (lastDate) {
        const date = new Date(backendCache.date);
        lastDate.textContent = date.toLocaleString('fr-FR');
      }
    } else {
      console.log('‚ÑπÔ∏è Aucune sauvegarde automatique trouv√©e');
      if (restoreBlock) restoreBlock.classList.add('hidden');
    }
  } catch (error) {
    console.error('‚ùå Erreur lors de la v√©rification du cache backend:', error);
  }
}

// ========== FONCTION MANQUANTE - Restaurer le cache ==========
async function restoreCache() {
  const cached = localStorage.getItem('cache-data');
  if (!cached) return;
  try {
    const data = JSON.parse(cached);
    localStorage.setItem('mode-selection', data.mode);
    await initRepartitionApp();
    // Appliquer la disposition sauvegard√©e
    if (data.disposition) {
      Object.entries(data.disposition).forEach(([classe, ids]) => {
        const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
        if (zone) {
          ids.forEach(id => {
            const card = document.querySelector(`.student-card[data-id="${id}"]`);
            if (card) zone.appendChild(card);
          });
        }
      });
    }
    updateAllColumnStats();
    toast('Cache restaur√© avec succ√®s', 'success');
  } catch (e) {
    console.error('Erreur restauration cache:', e);
    toast('Erreur lors de la restauration', 'error');
  }
}

// =======================================================
// VARIABLES GLOBALES
// =======================================================
let autoSaveInterval = null;

// D√âPLACER STATE ICI !
let STATE = {
    viewMode: 'complete',
    students: {},
    rules: {},
    aGroups: {},
    history: [],
    historyTimeline: [], // Ajout√© pour le panneau historique
    future: [],
    swapMode: false,
    swapFirst: null,
    adminMode: false,
    searchTerm: '',
    darkMode: false,
    zoomMode: false,
    fullscreenStats: false,
    anchoredStats: false,
    currentMode: null,
    originalData: null,
    niveau: '',
    sortOrder: {},
    lastSaveError: false,
    draggingElement: null,
    dragStartZone: null
};

// Variables pour les graphiques (les d√©placer aussi)
window.chartCommunication = null;
window.chartDistribution = null;
window.chartLV2 = null;
window.chartOptions = null;

// ============================================
// ARCHITECTURE MODULAIRE
// ============================================
/**
 * Architecture modulaire de l'application InterfaceV2
 *
 * Cette section organise le code JavaScript en modules logiques pour am√©liorer
 * l'organisation et la maintenabilit√© du code (12561 lignes).
 *
 * DOCUMENTATION COMPL√àTE : Voir ARCHITECTURE_MODULAIRE.md
 *
 * MODULES DISPONIBLES :
 * - App.state       : √âtat global de l'application (alias de STATE)
 * - App.UI          : Cr√©ation et manipulation des √©l√©ments UI
 * - App.DragDrop    : Gestion du drag and drop
 * - App.Views       : Gestion des diff√©rentes vues (simple, complete, swap, dark mode)
 * - App.History     : Historique et undo/redo
 * - App.Stats       : Statistiques et m√©triques
 * - App.Constraints : Validation des contraintes
 * - App.Data        : Import/Export et sauvegarde
 * - App.Search      : Recherche et filtres
 * - App.Utils       : Fonctions utilitaires
 * - App.Init        : Initialisation de l'application
 *
 * COMPATIBILIT√â :
 * Des fonctions wrapper globales sont disponibles pour assurer la compatibilit√©
 * avec le code existant. Voir section "FONCTIONS WRAPPER POUR COMPATIBILIT√â" ci-dessous.
 *
 * UTILISATION :
 * // Nouveau code (recommand√©)
 * App.UI.toast('Message', 'success');
 *
 * // Code legacy (toujours support√© via wrappers)
 * toast('Message', 'success');
 *
 * MIGRATION EN COURS :
 * ‚úÖ App.UI          - toast, updateColumnStats, showSpinner, etc.
 * ‚úÖ App.History     - undo, redo, updateUndoRedoButtons
 * ‚úÖ App.Stats       - updateAdvancedStats
 * ‚úÖ App.Data        - exportDisposition, saveImmediateCache
 * ‚úÖ App.Utils       - isRealClass
 * ‚è≥ App.Views       - √Ä migrer : toggleViewMode, toggleSwapMode, etc.
 * ‚è≥ App.DragDrop    - √Ä migrer : handleDragStart, handleDrop, etc.
 * ‚è≥ App.Constraints - √Ä migrer : canMove, canSwap
 * ‚è≥ App.Search      - √Ä migrer : searchStudents, filterByTag
 * ‚è≥ App.Init        - √Ä migrer : setupEventListeners, initApp
 */

const App = {
  // ============================================
  // √âTAT GLOBAL (r√©f√©rence vers STATE)
  // ============================================
  get state() {
    return STATE;
  },

  // ============================================
  // MODULE UI - Cr√©ation et manipulation des √©l√©ments
  // ============================================
  UI: {
    /**
     * Affiche une notification toast
     * @param {string} message - Message √† afficher
     * @param {string} type - Type de notification (info, success, error, warning)
     */
    toast(message, type = 'info') {
      const icons = {
        info: 'fa-info-circle',
        success: 'fa-check-circle',
        error: 'fa-exclamation-circle',
        warning: 'fa-exclamation-triangle'
      };

      const isSwapError = type === 'error';
      const toast = document.createElement('div');

      if (isSwapError) {
        toast.className = `toast ${type} fade-in`;
        toast.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 9999;
          font-size: 1.5rem;
          padding: 24px 40px;
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
          border-radius: 12px;
          background: #dc2626;
          color: white;
          border: none;
          font-weight: 600;
          min-width: 400px;
          text-align: center;
        `;
      } else {
        toast.className = `toast ${type} fixed bottom-4 right-4 z-50 fade-in`;
      }

      toast.innerHTML = `
        <i class="fas ${icons[type]} ${isSwapError ? 'text-2xl mr-3' : 'text-lg'}"></i>
        <span>${message}</span>
      `;

      document.body.appendChild(toast);

      const duration = isSwapError ? 4000 : 3000;

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s ease-out';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    },

    /**
     * Met √† jour les statistiques d'une colonne de classe
     * @param {HTMLElement} column - √âl√©ment DOM de la colonne
     * @param {Array} eleves - Liste des √©l√®ves
     */
    updateColumnStats(column, eleves) {
      if (!column) return;

      const count   = eleves.length;
      const countF  = eleves.filter(e => e.sexe === 'F').length;
      const countM  = eleves.filter(e => e.sexe === 'M').length;

      column.querySelector('.count').textContent    = count;
      column.querySelector('.count-f').textContent  = countF;
      column.querySelector('.count-m').textContent  = countM;

      const scoreCats = ['C', 'T', 'P', 'A'];
      const counters  = { C:[0,0,0,0], T:[0,0,0,0], P:[0,0,0,0], A:[0,0,0,0] };

      eleves.forEach(e => {
        scoreCats.forEach(cat => {
          const v = +e.scores?.[cat] || 0;
          if (v >= 1 && v <= 4) counters[cat][v-1]++;
        });
      });

      scoreCats.forEach(cat => {
        counters[cat].forEach((val, i) => {
          const el = column.querySelector(`.count-${cat.toLowerCase()}${i+1}`);
          if (el) el.textContent = val;
        });
      });
    },

    /**
     * Met √† jour les statistiques de toutes les colonnes
     */
    updateAllColumnStats() {
      console.log('üìä App.UI.updateAllColumnStats - version modulaire');

      document.querySelectorAll('.class-column').forEach(column => {
        const className = column.querySelector('.classe-name').textContent;
        if (!App.Utils.isRealClass(className)) return;

        const dropZone = column.querySelector('.droppable-zone');
        const cards = Array.from(dropZone.querySelectorAll('.student-card'));
        const eleves = cards.map(card => STATE.students[card.dataset.id]).filter(Boolean);

        App.UI.updateColumnStats(column, eleves);
      });
    },

    /**
     * Ajuste la taille de police des noms en vue simplifi√©e
     * @param {HTMLElement} dropZone - Zone de d√©p√¥t
     */
    adjustSimpleNamesFontSize(dropZone) {
      if (!STATE || STATE.viewMode !== 'simple') return;
      const cards = Array.from(dropZone.querySelectorAll('.student-card'));
      if (cards.length === 0) return;

      let zoneHeight = dropZone.clientHeight || dropZone.offsetHeight || 0;
      if (!zoneHeight) {
        const parent = dropZone.closest('.class-column');
        if (parent) zoneHeight = parent.clientHeight || parent.offsetHeight || 0;
      }
      if (!zoneHeight) return;

      const availableHeight = zoneHeight - 30;
      const minFont = 16;
      const maxFont = 32;
      let fontSize = Math.floor(availableHeight / cards.length) - 2;

      if (isNaN(fontSize) || fontSize < minFont) fontSize = minFont;
      if (fontSize > maxFont) fontSize = maxFont;

      cards.forEach(card => {
        const nameEl = card.querySelector('.student-simple-name');
        const lineEl = card.querySelector('.simple-line');
        if (nameEl) {
          nameEl.style.fontSize = fontSize + 'px';
          nameEl.style.lineHeight = (fontSize + 2) + 'px';
        }
        if (lineEl) {
          lineEl.style.height = (fontSize + 6) + 'px';
        }
      });
    },

    /**
     * Affiche/masque le spinner de chargement
     */
    showSpinner() {
      document.getElementById('loadingSpinner')?.classList.remove('hidden');
    },

    hideSpinner() {
      document.getElementById('loadingSpinner')?.classList.add('hidden');
    }
  },

  // ============================================
  // MODULE DRAG & DROP
  // ============================================
  DragDrop: {
    // Ces fonctions seront migr√©es depuis le code existant
    // Pour l'instant, on laisse des placeholders qui appelleront les fonctions globales
  },

  // ============================================
  // MODULE VIEWS - Gestion des vues
  // ============================================
  Views: {
    // Placeholders pour les fonctions de vue
  },

  // ============================================
  // MODULE HISTORY - Historique et undo/redo
  // ============================================
  History: {
    /**
     * Met √† jour l'√©tat des boutons undo/redo
     */
    updateUndoRedoButtons() {
      const btnUndo = document.getElementById('btnUndo');
      const btnRedo = document.getElementById('btnRedo');

      if (btnUndo) btnUndo.disabled = STATE.history.length === 0;
      if (btnRedo) btnRedo.disabled = STATE.future.length === 0;
    },

    /**
     * Annule la derni√®re action
     */
    undo() {
      if (STATE.history.length === 0) return;

      const action = STATE.history.pop();
      STATE.future.push(action);

      // Retirer aussi de historyTimeline
      if (STATE.historyTimeline.length > 0) {
        STATE.historyTimeline.pop();
      }

      if (action.type === 'move') {
        const card = document.querySelector(`.student-card[data-id="${action.eleveId}"]`);
        const oldZone = document.querySelector(`.droppable-zone[data-classe="${action.oldClasse}"]`);

        if (card && oldZone) {
          // Ins√©rer √† l'ancienne position si possible
          if (action.oldIndex < oldZone.children.length) {
            oldZone.insertBefore(card, oldZone.children[action.oldIndex]);
          } else {
            oldZone.appendChild(card);
          }
        }
      } else if (action.type === 'swap') {
        if (typeof performSwap === 'function') {
          performSwap(action.id2, action.id1); // Swap inverse
          STATE.history.pop(); // Enlever le swap ajout√© par performSwap
        }
      }

      App.History.updateUndoRedoButtons();
      App.UI.updateAllColumnStats();

      // Mettre √† jour le panneau historique
      if (typeof updateHistoryPanel === 'function') {
        updateHistoryPanel();
      }

      // Mise √† jour intelligente des statistiques
      setTimeout(() => App.Stats.updateAdvancedStats(), 150);

      // Sauvegarde apr√®s undo
      if (STATE.currentMode === 'CACHE') {
        App.Data.saveImmediateCache();
      }
    },

    /**
     * Refait la derni√®re action annul√©e
     */
    redo() {
      if (STATE.future.length === 0) return;

      const action = STATE.future.pop();

      if (action.type === 'move') {
        const card = document.querySelector(`.student-card[data-id="${action.eleveId}"]`);
        const newZone = document.querySelector(`.droppable-zone[data-classe="${action.newClasse}"]`);

        if (card && newZone) {
          if (action.newIndex < newZone.children.length) {
            newZone.insertBefore(card, newZone.children[action.newIndex]);
          } else {
            newZone.appendChild(card);
          }
        }
        STATE.history.push(action);
        // Ajouter aussi √† historyTimeline pour le panneau historique
        STATE.historyTimeline.push(action);
      } else if (action.type === 'swap') {
        if (typeof performSwap === 'function') {
          performSwap(action.id1, action.id2);
        }
      }

      App.History.updateUndoRedoButtons();
      App.UI.updateAllColumnStats();

      // Mettre √† jour le panneau historique
      if (typeof updateHistoryPanel === 'function') {
        updateHistoryPanel();
      }

      // Mise √† jour intelligente des statistiques
      setTimeout(() => App.Stats.updateAdvancedStats(), 150);

      // Sauvegarde apr√®s redo
      if (STATE.currentMode === 'CACHE') {
        App.Data.saveImmediateCache();
      }
    }
  },

  // ============================================
  // MODULE STATS - Statistiques
  // ============================================
  Stats: {
    /**
     * Met √† jour les statistiques avanc√©es
     */
    updateAdvancedStats() {
      console.log('üìä App.Stats.updateAdvancedStats',
                  'chartsReady=', window.areChartsReady?.(),
                  'typeof updateCharts =', typeof updateCharts);

      const panel = document.getElementById('statsPanel');
      if (!panel || panel.classList.contains('translate-x-full')) {
        console.log('üìä Panneau ferm√©, skip mise √† jour');
        return;
      }

      if (typeof updateNewMetrics === 'function') {
        console.log('üî¢ updateNewMetrics lanc√©');
        updateNewMetrics();
      }

      console.log('üìä Appel de updateCharts()...');
      if (typeof updateCharts === 'function') {
        updateCharts();
      }
      console.log('üìä updateCharts() termin√©');

      if (typeof updateLV2Details === 'function') {
        updateLV2Details();
      }
    }
  },

  // ============================================
  // MODULE CONSTRAINTS - Validation
  // ============================================
  Constraints: {
    // Placeholders pour les fonctions de contraintes
  },

  // ============================================
  // MODULE DATA - Import/Export
  // ============================================
  Data: {
    /**
     * Exporte la disposition actuelle
     * @returns {Object} Disposition des classes
     */
    exportDisposition() {
      const result = {};
      document.querySelectorAll('.class-column').forEach(column => {
        const classe = column.querySelector('.classe-name').textContent;
        const ids = Array.from(column.querySelectorAll('.student-card')).map(card => card.dataset.id);
        result[classe] = ids;
      });
      return result;
    },

    /**
     * Sauvegarde imm√©diate dans le cache
     */
    async saveImmediateCache() {
      try {
        const disposition = App.Data.exportDisposition();
        const cacheData = {
          date: new Date().toISOString(),
          disposition: disposition,
          mode: STATE.currentMode
        };

        localStorage.setItem('cache-data', JSON.stringify(cacheData));

        if (typeof gsRun === 'function') {
          try {
            const result = await gsRun('saveCacheData', cacheData);
            if (result && result.success) {
              console.log('üíæ Sauvegarde automatique CACHE r√©ussie');
            } else {
              console.warn('‚ö†Ô∏è Sauvegarde CACHE √©chou√©e:', result?.error);
            }
          } catch (error) {
            console.error('‚ùå Erreur sauvegarde CACHE:', error);
          }
        }
      } catch (error) {
        console.error('‚ùå Erreur dans saveImmediateCache:', error);
      }
    }
  },

  // ============================================
  // MODULE SEARCH - Recherche et filtres
  // ============================================
  Search: {
    // Placeholders pour les fonctions de recherche
  },

  // ============================================
  // MODULE UTILS - Utilitaires
  // ============================================
  Utils: {
    /**
     * V√©rifie si un nom de classe est une vraie classe (pas un groupe)
     * @param {string} className - Nom de la classe
     * @returns {boolean}
     */
    isRealClass(className) {
      const groupPatterns = [
        /^level_/i,
        /^grp_/i,
        /^groupe_/i,
        /^group_/i,
        /_Groupe\d*$/i,
        /^ESP_/i,
        /^ITA_/i,
        /^ALL_/i,
        /^LATIN_/i,
        /^MATH_/i,
        /^FR_/i,
        /^Niveau/i
      ];

      for (const pattern of groupPatterns) {
        if (pattern.test(className)) {
          return false;
        }
      }

      const classPattern = /^\d+¬∞\d+$/;
      return classPattern.test(className);
    }
  },

  // ============================================
  // MODULE INIT - Initialisation
  // ============================================
  Init: {
    // Placeholders pour l'initialisation
  }
};

// ============================================
// FONCTIONS WRAPPER POUR COMPATIBILIT√â
// ============================================
/**
 * Ces fonctions wrapper assurent la compatibilit√© avec les event handlers HTML existants
 * et le code legacy. Elles d√©l√®guent simplement vers les modules appropri√©s.
 */

// Wrapper pour toast
function toast(message, type = 'info') {
  return App.UI.toast(message, type);
}

// Wrapper pour updateColumnStats
function updateColumnStats(column, eleves) {
  return App.UI.updateColumnStats(column, eleves);
}

// Wrapper pour updateAllColumnStats
function updateAllColumnStats() {
  return App.UI.updateAllColumnStats();
}

// Wrapper pour adjustSimpleNamesFontSize
function adjustSimpleNamesFontSize(dropZone) {
  return App.UI.adjustSimpleNamesFontSize(dropZone);
}

// Wrapper pour isRealClass
function isRealClass(className) {
  return App.Utils.isRealClass(className);
}

// Wrapper pour exportDisposition
function exportDisposition() {
  return App.Data.exportDisposition();
}

// Wrapper pour saveImmediateCache
async function saveImmediateCache() {
  return App.Data.saveImmediateCache();
}

// Wrapper pour updateUndoRedoButtons
function updateUndoRedoButtons() {
  return App.History.updateUndoRedoButtons();
}

// Wrapper pour updateAdvancedStats
function updateAdvancedStats() {
  return App.Stats.updateAdvancedStats();
}

// Wrapper pour undo
function undo() {
  return App.History.undo();
}

// Wrapper pour redo
function redo() {
  return App.History.redo();
}

// Wrapper pour showSpinner/hideSpinner
function showSpinner() {
  return App.UI.showSpinner();
}

function hideSpinner() {
  return App.UI.hideSpinner();
}

// =======================================================
// FONCTIONS GLOBALES (Legacy - √Ä migrer progressivement)
// =======================================================
// showSpinner() et hideSpinner() migr√©s vers App.UI






// ========== AJUSTEMENT TAILLE DES CARTES ==========
function resizeCards(){
  document.querySelectorAll('.student-card').forEach(card=>{
    const w = card.offsetWidth;
    // Toujours retirer toutes les classes
    card.classList.remove('card-sm','card-md','card-lg');
    // Puis ajouter la classe appropri√©e
    if     (w > 320) card.classList.add('card-lg');
    else if(w > 240) card.classList.add('card-md');
    else             card.classList.add('card-sm');
  });
}






// ========== FONCTION D'OUVERTURE DU MODAL DE D√âMARRAGE ==========
// Fonction d√©j√† d√©finie plus haut

// =======================================================
// INITIALISATION QUAND LE DOM EST PR√äT
// =======================================================
window.addEventListener('DOMContentLoaded', (event) => {
  console.log("DOM pr√™t. Tous les scripts peuvent s'ex√©cuter.");

  // V√©rifier si une sauvegarde CACHE existe
  checkCache();

  // GESTION DU MODAL DE D√âMARRAGE
  const startupModal = document.getElementById('startupModal');
  const closeStartupModalBtn = document.getElementById('closeStartupModal');

  if (closeStartupModalBtn && startupModal) {
    closeStartupModalBtn.addEventListener('click', () => {
      startupModal.classList.add('hidden');
    });

    startupModal.querySelectorAll('button[data-mode]').forEach(btn => {
      btn.addEventListener('click', async e => {
        const mode = e.currentTarget.dataset.mode;

        if ((mode === 'PREVIOUS' || mode === 'FIN') && !STATE.adminMode) {
          const password = prompt('Veuillez entrer le mot de passe administrateur :', '');
          if (password === null) return;
          try {
            const result = await gsRun('verifierMotDePasseAdmin', password);
            if (!result || !result.success) { alert('Mot de passe incorrect.'); return; }
            STATE.adminMode = true;
          } catch (err) {
            alert('Erreur lors de la v√©rification du mot de passe.');
            return;
          }
        }

        localStorage.setItem('mode-selection', mode);
        startupModal.classList.add('hidden');
        initRepartitionApp();
      });
    });
  }

  // =======================================================
  // 1. GESTION DES OPTIONS DE LISIBILIT√â
  // =======================================================
  (function() {
    const toggleBtn = document.getElementById('btnLisibilite');
    const panel = document.getElementById('lisibilite-panel');
    const closeBtn = document.getElementById('close-lisibilite-panel');
    const resetBtn = document.getElementById('reset-lisibilite');
    const fullscreenBtn = document.getElementById('fullscreen-mode');

    // On v√©rifie que les √©l√©ments critiques existent avant de continuer
    if (!toggleBtn || !panel || !closeBtn) {
        console.warn('Certains √©l√©ments du panneau de lisibilit√© sont introuvables. Fonctionnalit√© d√©sactiv√©e.');
        return;
    }
  
  // √âtat des options de lisibilit√©
  let lisibiliteState = {
    size: 'medium',
    style: 'normal',
    contrast: 'normal',
    symbols: 'colors',
    showPrenoms: true,
    showClasse: true,
    showScores: true
  };
  
  // Charger les pr√©f√©rences sauvegard√©es
  function loadPreferences() {
    const saved = localStorage.getItem('lisibilite-preferences');
    if (saved) {
      lisibiliteState = { ...lisibiliteState, ...JSON.parse(saved) };
      applyPreferences();
    }
  }
  
  // Sauvegarder les pr√©f√©rences
  function savePreferences() {
    localStorage.setItem('lisibilite-preferences', JSON.stringify(lisibiliteState));
  }
  
  // Appliquer les pr√©f√©rences aux noms (vue normale ET simplifi√©e)
  function applyPreferences() {
    // Vue normale
    const names = document.querySelectorAll('.student-fullname');
    names.forEach(name => {
      name.classList.remove('size-small', 'size-medium', 'size-large', 'size-xlarge');
      name.classList.remove('style-normal', 'style-bold', 'style-highlight', 'style-outline');
      name.classList.add(`size-${lisibiliteState.size}`);
      name.classList.add(`style-${lisibiliteState.style}`);
      name.style.color = '';
      name.style.background = '';
      name.style.fontWeight = '';
      // Contraste √©lev√©/max : forcer noir/blanc, sinon laisser couleur par d√©faut
      if (lisibiliteState.contrast === 'high' || lisibiliteState.contrast === 'max') {
        name.style.color = '#000';
        name.style.textShadow = lisibiliteState.contrast === 'max'
          ? '2px 2px 0 #fff, -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff'
          : '1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff';
        name.style.fontWeight = '900';
      } else {
        name.style.color = '';
        name.style.textShadow = '';
      }
      // Style highlight/outline
      if (lisibiliteState.style === 'highlight') {
        name.style.background = '#fef3c7';
      }
      if (lisibiliteState.style === 'outline') {
        name.style.border = '2px solid #3b82f6';
        name.style.borderRadius = '3px';
      } else {
        name.style.border = '';
        name.style.borderRadius = '';
      }
      // Symboles/genres
      const card = name.closest('.student-card');
      if (card) {
        card.classList.remove('symbols-colors', 'symbols-symbols', 'symbols-both');
        card.classList.add(`symbols-${lisibiliteState.symbols}`);
        // Fond blanc forc√© si symboles ou contraste, sinon couleur par d√©faut
        if (lisibiliteState.symbols !== 'colors' || lisibiliteState.contrast !== 'normal') {
          card.style.background = '#fff';
          card.style.borderColor = '#bbb';
        } else {
          card.style.background = '';
          card.style.borderColor = '';
        }
      }
    });
    // Vue simplifi√©e
    const simpleNames = document.querySelectorAll('.student-simple-name');
    simpleNames.forEach(name => {
      name.style.fontSize =
        lisibiliteState.size === 'small' ? '0.75rem' :
        lisibiliteState.size === 'medium' ? '0.95rem' :
        lisibiliteState.size === 'large' ? '1.15rem' :
        '1.35rem';
      name.style.fontWeight = lisibiliteState.style === 'bold' ? '700' :
        lisibiliteState.style === 'highlight' ? '700' :
        lisibiliteState.style === 'outline' ? '700' :
        '600';
      name.style.background = lisibiliteState.style === 'highlight' ? '#fef3c7' : '';
      name.style.border = lisibiliteState.style === 'outline' ? '2px solid #3b82f6' : '';
      name.style.borderRadius = lisibiliteState.style === 'outline' ? '3px' : '';
      // En mode simplifi√©, toujours fond blanc et police noire
      name.style.color = '#000';
      name.style.textShadow = '';
      name.style.fontWeight = '900';
      const card = name.closest('.student-card');
      if (card) {
        card.classList.remove('symbols-colors', 'symbols-symbols', 'symbols-both');
        card.classList.add(`symbols-${lisibiliteState.symbols}`);
        card.style.background = '#fff';
        card.style.borderColor = '#bbb';
      }
    });
    // Appliquer le contraste au body
    document.body.classList.remove('contrast-high', 'contrast-max');
    if (lisibiliteState.contrast !== 'normal') {
      document.body.classList.add(`contrast-${lisibiliteState.contrast}`);
    }
    // Appliquer les symboles aux cartes (vue normale)
    const cards = document.querySelectorAll('.student-card');
    cards.forEach(card => {
      card.classList.remove('symbols-colors', 'symbols-symbols', 'symbols-both');
      card.classList.add(`symbols-${lisibiliteState.symbols}`);
      // Fond blanc forc√© si symboles ou contraste, sinon couleur par d√©faut
      if (lisibiliteState.symbols !== 'colors' || lisibiliteState.contrast !== 'normal') {
        card.style.background = '#fff';
        card.style.borderColor = '#bbb';
      } else {
        card.style.background = '';
        card.style.borderColor = '';
      }
    });

    // G√©rer l'affichage des pr√©noms (nom seul si d√©coch√©e)
    const allNames = document.querySelectorAll('.student-fullname, .student-simple-name');
    allNames.forEach(nameEl => {
      const card = nameEl.closest('.student-card');
      if (!card || !card.dataset.id) return;

      const eleve = STATE.students[card.dataset.id];
      if (!eleve) return;

      if (lisibiliteState.showPrenoms) {
        // Afficher nom + pr√©nom SIMPLIFI√â VERSION 4.0
        nameEl.textContent = simplifierNomComplet(eleve.nom, eleve.prenom);
      } else {
        // Afficher nom uniquement
        nameEl.textContent = eleve.nom;
      }
    });

    // G√©rer l'affichage de la classe d'origine
    const sourceElements = document.querySelectorAll('.source-class');
    sourceElements.forEach(el => {
      el.style.display = lisibiliteState.showClasse ? '' : 'none';
    });

    // G√©rer l'affichage des badges de scores
    const scoresElements = document.querySelectorAll('.scores');
    scoresElements.forEach(el => {
      el.style.display = lisibiliteState.showScores ? '' : 'none';
    });

    updateActiveButtons();
    updateCheckboxes();
  }
  
  // Mettre √† jour les boutons actifs
  function updateActiveButtons() {
    document.querySelectorAll('.btn-lisibilite').forEach(btn => {
      btn.classList.remove('active');
    });
    
    document.querySelectorAll(`[data-size="${lisibiliteState.size}"]`).forEach(btn => btn.classList.add('active'));
    document.querySelectorAll(`[data-style="${lisibiliteState.style}"]`).forEach(btn => btn.classList.add('active'));
    document.querySelectorAll(`[data-contrast="${lisibiliteState.contrast}"]`).forEach(btn => btn.classList.add('active'));
    document.querySelectorAll(`[data-symbols="${lisibiliteState.symbols}"]`).forEach(btn => btn.classList.add('active'));
  }

  // Mettre √† jour les checkboxes
  function updateCheckboxes() {
    const prenomsCheckbox = document.getElementById('toggle-prenoms');
    const classeCheckbox = document.getElementById('toggle-classe');
    const scoresCheckbox = document.getElementById('toggle-scores');

    if (prenomsCheckbox) prenomsCheckbox.checked = lisibiliteState.showPrenoms;
    if (classeCheckbox) classeCheckbox.checked = lisibiliteState.showClasse;
    if (scoresCheckbox) scoresCheckbox.checked = lisibiliteState.showScores;
  }

  // Gestion des clics sur les boutons d'options
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('btn-lisibilite')) {
      const type = e.target.dataset.size || e.target.dataset.style || e.target.dataset.contrast || e.target.dataset.symbols;
      const category = e.target.dataset.size ? 'size' : e.target.dataset.style ? 'style' : e.target.dataset.contrast ? 'contrast' : 'symbols';
      
      lisibiliteState[category] = type;
      applyPreferences();
      savePreferences();
    }
  });

  // Gestion des checkboxes pour affichage
  const prenomsCheckbox = document.getElementById('toggle-prenoms');
  const classeCheckbox = document.getElementById('toggle-classe');
  const scoresCheckbox = document.getElementById('toggle-scores');

  if (prenomsCheckbox) {
    prenomsCheckbox.addEventListener('change', (e) => {
      lisibiliteState.showPrenoms = e.target.checked;
      applyPreferences();
      savePreferences();
    });
  }

  if (classeCheckbox) {
    classeCheckbox.addEventListener('change', (e) => {
      lisibiliteState.showClasse = e.target.checked;
      applyPreferences();
      savePreferences();
    });
  }

  if (scoresCheckbox) {
    scoresCheckbox.addEventListener('change', (e) => {
      lisibiliteState.showScores = e.target.checked;
      applyPreferences();
      savePreferences();
    });
  }

  // Gestion de l'ouverture/fermeture du panneau
  if (toggleBtn && panel && closeBtn) {
    toggleBtn.addEventListener('click', () => {
      panel.classList.remove('-translate-y-full');
      panel.classList.add('translate-y-0');
    });
    closeBtn.addEventListener('click', () => {
      panel.classList.remove('translate-y-0');
      panel.classList.add('-translate-y-full');
    });
  }
  
  // R√©initialiser les options
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      lisibiliteState = {
        size: 'medium',
        style: 'normal',
        contrast: 'normal',
        symbols: 'colors',
        showPrenoms: true,
        showClasse: true,
        showScores: true
      };
      applyPreferences();
      savePreferences();
    });
  }
  
  // Mode plein √©cran
  if (fullscreenBtn) {
    fullscreenBtn.addEventListener('click', async () => {
      try {
        if (document.fullscreenElement) {
          await document.exitFullscreen();
        } else {
          await document.documentElement.requestFullscreen();
        }
      } catch (error) {
        console.error('Erreur mode plein √©cran:', error);
        toast('Erreur mode plein √©cran. V√©rifiez les permissions du navigateur.', 'error');
      }
    });
    
    // Gestion des √©v√©nements fullscreen pour mettre √† jour le bouton
    document.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement) {
        fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Quitter plein √©cran';
        document.body.classList.add('fullscreen-mode');
      } else {
        fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Mode plein √©cran';
        document.body.classList.remove('fullscreen-mode');
      }
    });
  }
  
  // Charger les pr√©f√©rences au d√©marrage
  loadPreferences();
  
  // Appliquer les pr√©f√©rences quand de nouveaux √©l√®ves sont charg√©s
  const originalRenderBoard = window.renderBoard;
  if (originalRenderBoard) {
    window.renderBoard = function(...args) {
      const result = originalRenderBoard.apply(this, args);
      setTimeout(applyPreferences, 100); // Appliquer apr√®s le rendu
      return result;
    };
  }

  // Appliquer les pr√©f√©rences apr√®s chaque bascule de vue
  window.applyLisibilitePreferences = applyPreferences;
  })();


  // =======================================================
  // 2. LOGIQUE PRINCIPALE DE L'APPLICATION
  // =======================================================
  
  // TOUT votre code principal va ici, de "const CONFIG = ..." jusqu'√† la fin
  const CONFIG = {
    adminPassword: 'admin123',
    animation: {
      duration: 150
    }
  };
  
  // ========== GESTIONNAIRE D'ERREURS ==========
  window.addEventListener('error', (e) => {
    console.error('Erreur captur√©e:', e.message);
    e.preventDefault();
  });

  /* ---------- helper : √©l√®ve vraiment valide --------- */
  function isValidStudent(e) {
    return e                     // objet pr√©sent
        && e.id && e.id.trim()   // id non-vide
        && e.nom && e.nom.trim();/* au moins un NOM non-vide  */
  }
  
 
  
  
  // ========== MISE √Ä JOUR DES STATISTIQUES ==========
  // Fonctions d√©j√† d√©finies plus haut
  

  
  // Fonction pour d√©placer automatiquement un groupe A
  function moveGroupA(eleveId, srcClasse, dstClasse) {
    const eleve = STATE.students[eleveId];
    if (!eleve.asso) return;
    
    const group = STATE.aGroups[`A${eleve.asso}`] || [];
    const movedMembers = [];
    
    // D√©placer tous les membres du groupe qui sont dans srcClasse
    group.forEach(memberId => {
      const memberCard = document.querySelector(`.student-card[data-id="${memberId}"]`);
      if (!memberCard) return;
      
      const memberClasse = memberCard.closest('.droppable-zone').dataset.classe;
      if (memberClasse === srcClasse) {
        const dstZone = document.querySelector(`.droppable-zone[data-classe="${dstClasse}"]`);
        if (dstZone) {
          dstZone.appendChild(memberCard);
          movedMembers.push(STATE.students[memberId].nom);
        }
      }
    });
    
    if (movedMembers.length > 1) {
      toast(`Groupe A${eleve.asso} d√©plac√© : ${movedMembers.join(', ')}`, 'info');
    }
  }
  
  // ========== GESTION DES SWAPS - REMPLACEMENT COMPLET ==========
  // Remplacez TOUTE la section de gestion des swaps par ce code
  
  // Fonction pour v√©rifier si un swap est possible
  
  
  
  // Fonction pour g√©rer le clic sur une carte
  
  
  // Fonction pour activer/d√©sactiver le mode swap
  function toggleSwapMode() {
    STATE.swapMode = !STATE.swapMode;
    STATE.swapFirst = null;

    const btnSwapMain = document.getElementById('btnSwapMain');
    const sortables = document.querySelectorAll('.droppable-zone');

    if (STATE.swapMode) {
      if (btnSwapMain) {
        btnSwapMain.classList.add('active', 'btn-primary');
        btnSwapMain.classList.remove('btn-secondary');
        btnSwapMain.setAttribute('aria-pressed', 'true');
      }
      toast('üîÑ Mode SWAP activ√© - Cliquez sur deux √©l√®ves pour les √©changer', 'info');

      // D√©sactiver le drag & drop
      sortables.forEach(zone => {
        const sortable = Sortable.get(zone);
        if (sortable) sortable.option('disabled', true);
      });
    } else {
      if (btnSwapMain) {
        btnSwapMain.classList.remove('active', 'btn-primary');
        btnSwapMain.classList.add('btn-secondary');
        btnSwapMain.setAttribute('aria-pressed', 'false');
      }

      // R√©activer le drag & drop
      sortables.forEach(zone => {
        const sortable = Sortable.get(zone);
        if (sortable) sortable.option('disabled', false);
      });

      // Nettoyer les s√©lections
      document.querySelectorAll('.student-card').forEach(card => {
        card.classList.remove('swap-mode');
      });
      document.querySelectorAll('.droppable-zone').forEach(zone => {
        zone.classList.remove('swap-target');
      });

      toast('Mode normal r√©tabli', 'info');
    }
  }
  
  // S'assurer que performSwapAndClose est bien d√©fini pour la modal
  window.performSwapAndClose = function(id1, id2) {
    performSwap(id1, id2);
    
  }
  
  // ========== SUGGESTIONS DE SWAPS ==========
  function findSwapSuggestions() {
    const suggestions = [];
    const classes = Object.keys(STATE.rules);
    
    // Analyser chaque paire de classes
    for (let i = 0; i < classes.length; i++) {
      for (let j = i + 1; j < classes.length; j++) {
        const classe1 = classes[i];
        const classe2 = classes[j];
        
        const students1 = getCurrentClassContent(classe1).map(id => STATE.students[id]);
        const students2 = getCurrentClassContent(classe2).map(id => STATE.students[id]);
        
        // Chercher des swaps √©quilibrants
        students1.forEach(s1 => {
          students2.forEach(s2 => {
            // V√©rifier si le swap est possible
            const check = canSwap(s1.id, s2.id);
            if (!check.ok) return;
            
            // Calculer l'am√©lioration (exemple : √©quilibrage des sexes)
            const countF1 = students1.filter(s => s.sexe === 'F').length;
            const countM1 = students1.filter(s => s.sexe === 'M').length;
            const countF2 = students2.filter(s => s.sexe === 'F').length;
            const countM2 = students2.filter(s => s.sexe === 'M').length;
            
            const diffBefore = Math.abs(countF1 - countM1) + Math.abs(countF2 - countM2);
            
            const newCountF1 = countF1 + (s2.sexe === 'F' ? 1 : 0) - (s1.sexe === 'F' ? 1 : 0);
            const newCountM1 = countM1 + (s2.sexe === 'M' ? 1 : 0) - (s1.sexe === 'M' ? 1 : 0);
            const newCountF2 = countF2 + (s1.sexe === 'F' ? 1 : 0) - (s2.sexe === 'F' ? 1 : 0);
            const newCountM2 = countM2 + (s1.sexe === 'M' ? 1 : 0) - (s2.sexe === 'M' ? 1 : 0);
            
            const diffAfter = Math.abs(newCountF1 - newCountM1) + Math.abs(newCountF2 - newCountM2);
            
            if (diffAfter < diffBefore) {
              suggestions.push({
                student1: s1,
                student2: s2,
                classe1,
                classe2,
                improvement: diffBefore - diffAfter,
                reason: '√âquilibrage des sexes'
              });
            }
          });
        });
      }
    }
    
    // Trier par am√©lioration d√©croissante
    suggestions.sort((a, b) => b.improvement - a.improvement);
    
    return suggestions.slice(0, 10); // Top 10
  }
  
   
 
  
  // ========== GESTION UNDO/REDO ==========
// Fonctions d√©j√† d√©finies plus haut
  
  // ========== MODE ADMIN ==========
  function toggleAdminMode() {
    if (!STATE.adminMode) {
      // Demander le mot de passe
      const password = prompt('Entrez le mot de passe administrateur :');
      if (password === CONFIG.adminPassword) {
        STATE.adminMode = true;
        document.getElementById('btnAdmin').classList.add('active');
        document.getElementById('btnAdmin').innerHTML = '<i class="fas fa-lock"></i> Admin ON';
        toast('Mode administrateur activ√© - Toutes les r√®gles sont d√©sactiv√©es', 'warning');
      } else {
        toast('Mot de passe incorrect', 'error');
      }
    } else {
      STATE.adminMode = false;
      document.getElementById('btnAdmin').classList.remove('active');
      document.getElementById('btnAdmin').innerHTML = '<i class="fas fa-unlock-alt"></i> Admin';
      toast('Mode administrateur d√©sactiv√©', 'info');
    }
  }
  
  // ========== RECHERCHE ==========
  function setupSearch() {
    const searchInput = document.getElementById('search');
    
    if (!searchInput) return;
    
    searchInput.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      STATE.searchTerm = term;
      
      document.querySelectorAll('.student-card').forEach(card => {
        const nameEl = card.querySelector('.student-fullname, .student-simple-name');
        if (!nameEl) return;
        
        const fullName = nameEl.textContent.toLowerCase();
        const match = !term || fullName.includes(term);
        
        card.style.display = match ? '' : 'none';
        card.classList.toggle('search-highlight', match && term);
      });
    });
  }
  


// ========== FONCTIONS DE GESTION DES MODES ==========
function openStartupModal(opts = {}) {
  const modal = document.getElementById('startupModal');
  if (!modal) return;

  // Si le tableau de r√©partition est d√©j√† affich√©, ne rien faire
  const board = document.getElementById('board');
  if (board && board.innerHTML.trim() !== '' && !(opts && opts.force)) {
    return;
  }

  // Sinon, toujours afficher le panneau
  modal.classList.remove('hidden');
  checkCache(); // V√©rifier et afficher la derni√®re sauvegarde automatique
}



// ========== FONCTIONS DE GESTION DES VUES ==========
function toggleViewMode() {
  // Cycle: complete ‚Üí essential ‚Üí simple ‚Üí complete
  const modes = ['complete', 'essential', 'simple'];
  const currentIndex = modes.indexOf(STATE.viewMode);
  const nextIndex = (currentIndex + 1) % modes.length;
  STATE.viewMode = modes[nextIndex];

  localStorage.setItem('viewMode', STATE.viewMode);

  // Mettre √† jour les classes body
  document.body.classList.remove('simple-view', 'essential-view');
  if (STATE.viewMode === 'simple') {
    document.body.classList.add('simple-view');
  } else if (STATE.viewMode === 'essential') {
    document.body.classList.add('essential-view');
  }

  // Mettre √† jour le texte du bouton et aria-pressed
  const btn = document.getElementById('btnSimpleView');
  const textSpan = document.getElementById('viewModeText');
  if (btn && textSpan) {
    const modeLabels = {
      'complete': 'Essentielle',
      'essential': 'Simple',
      'simple': 'Compl√®te'
    };
    textSpan.textContent = modeLabels[STATE.viewMode];
    // Mettre √† jour aria-pressed (true si mode diff√©rent de complete)
    btn.setAttribute('aria-pressed', STATE.viewMode !== 'complete');
  }

  // Recr√©er toutes les cartes pour appliquer la nouvelle vue
  document.querySelectorAll('.droppable-zone').forEach(zone => {
    const ids = Array.from(zone.querySelectorAll('.student-card')).map(c => c.dataset.id);
    zone.innerHTML = '';
    ids.forEach(id => {
      if (STATE.students && STATE.students[id]) {
        const card = createStudentCard(STATE.students[id]);
        if (card) zone.appendChild(card);
      }
    });
    setTimeout(() => adjustSimpleNamesFontSize(zone), 0);
  });
  if (window.applyLisibilitePreferences) {
    window.applyLisibilitePreferences();
  }
}

// Fonction adjustSimpleNamesFontSize d√©j√† d√©finie plus haut
  
  // ========== EXPORT DE LA DISPOSITION ==========
// Fonction d√©j√† d√©finie plus haut
  
  // ========== EXPORT EXCEL ==========
  window.exportExcel = function() {
    const wb = XLSX.utils.book_new();
    
    // Feuille de r√©partition
    const data = [];
    document.querySelectorAll('.class-column').forEach(column => {
      const classe = column.querySelector('.classe-name').textContent;
      const cards = Array.from(column.querySelectorAll('.student-card'));
      
      cards.forEach(card => {
        const eleve = STATE.students[card.dataset.id];
        data.push({
          Classe: classe,
          Nom: eleve.nom,
          Pr√©nom: eleve.prenom,
          Sexe: eleve.sexe,
          LV2: eleve.lv2,
          Option: eleve.opt,
          Dissociation: eleve.disso ? `D${eleve.disso}` : '',
          Association: eleve.asso ? `A${eleve.asso}` : '',
          'Score COM': eleve.scores.COM,
          'Score TRA': eleve.scores.TRA,
          'Score PART': eleve.scores.PART,
          'Score ABS': eleve.scores.ABS,
          'Classe origine': eleve.source,
          Mobilit√©: eleve.mobilite
        });
      });
    });
    
    const ws = XLSX.utils.json_to_sheet(data);
    XLSX.utils.book_append_sheet(wb, ws, "R√©partition");
    
    // Feuille de statistiques
    const stats = [];
    document.querySelectorAll('.class-column').forEach(column => {
      const classe = column.querySelector('.classe-name').textContent;
      const count = column.querySelector('.count').textContent;
      const countF = column.querySelector('.count-f').textContent;
      const countM = column.querySelector('.count-m').textContent;
      
      stats.push({
        Classe: classe,
        'Total √©l√®ves': count,
        Filles: countF,
        Gar√ßons: countM,
        'Ratio F/M': `${Math.round(countF/count*100)}% / ${Math.round(countM/count*100)}%`
      });
    });
    
    const wsStats = XLSX.utils.json_to_sheet(stats);
    XLSX.utils.book_append_sheet(wb, wsStats, "Statistiques");
    
    // T√©l√©charger
    const niveau = STATE.niveau.replace('¬∞', 'e') || 'classes';
    XLSX.writeFile(wb, `repartition_${niveau}_${new Date().toISOString().split('T')[0]}.xlsx`);
    
    toast('Export Excel g√©n√©r√© avec succ√®s', 'success');
    closeExportModal();
  }
  
  // ========== EXPORT PDF ==========
  window.exportPDF = async function() {
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p', 'mm', 'a4');
    
    // Titre
    pdf.setFontSize(20);
    pdf.text(`R√©partition des Classes - ${STATE.niveau}`, 105, 20, { align: 'center' });
    
    // Date
    pdf.setFontSize(12);
    pdf.text(new Date().toLocaleDateString('fr-FR'), 105, 30, { align: 'center' });
    
    let yPos = 50;
    
    // Pour chaque classe
    document.querySelectorAll('.class-column').forEach((column, index) => {
      if (yPos > 250) {
        pdf.addPage();
        yPos = 20;
      }
      
      const classe = column.querySelector('.classe-name').textContent;
      const count = column.querySelector('.count').textContent;
      const countF = column.querySelector('.count-f').textContent;
      const countM = column.querySelector('.count-m').textContent;
      
      // Titre de la classe
      pdf.setFontSize(16);
      pdf.setTextColor(91, 33, 182); // Primary color
      pdf.text(classe, 20, yPos);
      
      // Stats
      pdf.setFontSize(10);
      pdf.setTextColor(0, 0, 0);
      pdf.text(`Total: ${count} √©l√®ves (${countF} filles, ${countM} gar√ßons)`, 60, yPos);
      
      yPos += 10;
      
      // Liste des √©l√®ves
      const cards = Array.from(column.querySelectorAll('.student-card'));
      cards.forEach((card, i) => {
        if (yPos > 270) {
          pdf.addPage();
          yPos = 20;
        }
        
        const eleve = STATE.students[card.dataset.id];
        const text = `${i + 1}. ${eleve.nom} ${eleve.prenom} - ${eleve.lv2}${eleve.opt ? '/' + eleve.opt : ''}`;
        pdf.text(text, 25, yPos);
        yPos += 5;
      });
      
      yPos += 10;
    }); // ‚Üê Fin de la boucle sur les colonnes

    // Ajouter les graphiques si le panel stats est ouvert
    if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
      pdf.addPage();
      pdf.setFontSize(16);
      pdf.text('Statistiques', 105, 20, { align: 'center' });

      // Capturer les graphiques
      const canvas1 = document.getElementById('chartStacked');
      if (canvas1) {
        const imgData1 = canvas1.toDataURL('image/png');
        pdf.addImage(imgData1, 'PNG', 20, 40, 170, 80);
      }

      const canvas2 = document.getElementById('chartDetailed');
      if (canvas2) {
        const imgData2 = canvas2.toDataURL('image/png');
        pdf.addImage(imgData2, 'PNG', 20, 130, 170, 80);
      }
    }

    const niveau = STATE.niveau.replace('¬∞', 'e') || 'classes';
    pdf.save(`repartition_${niveau}_${new Date().toISOString().split('T')[0]}.pdf`);

    toast('Export PDF g√©n√©r√© avec succ√®s', 'success');
    closeExportModal();
  } // ‚Üê Fin correcte de la fonction exportPDF
  
  // ========== COMPARAISON AVANT/APR√àS ==========
  window.showComparison = function() {
    if (!STATE.originalData) {
      toast('Aucune donn√©e de comparaison disponible', 'warning');
      return;a
    }
    
    // Cr√©er une modal de comparaison
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 1200px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">Comparaison avant/apr√®s r√©partition</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="comparison-container">
            <div class="comparison-side">
              <h3>√âtat initial</h3>
              <div id="comparisonBefore"></div>
            </div>
            <div class="comparison-side">
              <h3>√âtat actuel</h3>
              <div id="comparisonAfter"></div>
            </div>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Remplir les donn√©es
    const beforeContainer = modal.querySelector('#comparisonBefore');
    const afterContainer = modal.querySelector('#comparisonAfter');
    
    // √âtat initial
    STATE.originalData.forEach(group => {
      const div = document.createElement('div');
      div.className = 'mb-4';
      div.innerHTML = `
        <h4 class="font-bold">${group.classe}</h4>
        <p>Total: ${group.eleves.length} √©l√®ves</p>
        <p>F/M: ${group.eleves.filter(e => e.sexe === 'F').length}/${group.eleves.filter(e => e.sexe === 'M').length}</p>
      `;
      beforeContainer.appendChild(div);
    });
    
    // √âtat actuel
    document.querySelectorAll('.class-column').forEach(column => {
      const classe = column.querySelector('.classe-name').textContent;
      const count = column.querySelector('.count').textContent;
      const countF = column.querySelector('.count-f').textContent;
      const countM = column.querySelector('.count-m').textContent;
      
      const div = document.createElement('div');
      div.className = 'mb-4';
      div.innerHTML = `
        <h4 class="font-bold">${classe}</h4>
        <p>Total: ${count} √©l√®ves</p>
        <p>F/M: ${countF}/${countM}</p>
      `;
      afterContainer.appendChild(div);
    });
    
    closeExportModal();
  }
  
  // ========== MODAL EXPORT ==========
  window.closeExportModal = function() {
    document.getElementById('exportModal').classList.add('hidden');
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('overlay').classList.remove('active');
  }
  
  // ========== √âDITION DES R√àGLES ==========
  function openRulesModal() {
    const container = document.getElementById('rulesContainer');
    container.innerHTML = '';
    
    // Pour chaque classe
    Object.keys(STATE.rules).forEach(classe => {
      const rule = STATE.rules[classe];
      
      const div = document.createElement('div');
      div.className = 'mb-6 p-4 border rounded-lg';
      div.innerHTML = `
        <h3 class="font-bold text-lg mb-3">${classe}</h3>
        <div class="grid grid-cols-2 gap-4">
          <div class="form-group">
            <label class="form-label">Capacit√© maximale</label>
            <input type="number" class="form-control" 
              data-classe="${classe}" 
              data-field="capacity" 
              value="${rule.capacity || 28}" 
              min="1" max="35">
          </div>
          <div class="form-group">
            <label class="form-label">Quotas (format: OPT=nombre)</label>
            <textarea class="form-control" 
              data-classe="${classe}" 
              data-field="quotas" 
              rows="3">${Object.entries(rule.quotas || {}).map(([k, v]) => `${k}=${v}`).join(', ')}</textarea>
          </div>
        </div>
      `;
      
      container.appendChild(div);
    });
    
    document.getElementById('rulesModal').classList.remove('hidden');
    document.getElementById('overlay').classList.remove('hidden');
    document.getElementById('overlay').classList.add('active');
  }
  
  window.closeRulesModal = function() {
    document.getElementById('rulesModal').classList.add('hidden');
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('overlay').classList.remove('active');
  }
  
  window.saveRules = async function() {
    const newRules = {};
    
    // Collecter les nouvelles r√®gles
    document.querySelectorAll('#rulesContainer input, #rulesContainer textarea').forEach(input => {
      const classe = input.dataset.classe;
      const field = input.dataset.field;
      
      if (!newRules[classe]) {
        newRules[classe] = { capacity: 28, quotas: {} };
      }
      
      if (field === 'capacity') {
        newRules[classe].capacity = parseInt(input.value) || 28;
      } else if (field === 'quotas') {
        // Parser les quotas
        const quotasStr = input.value;
        quotasStr.split(',').forEach(pair => {
          const [opt, val] = pair.split('=').map(s => s.trim());
          if (opt && val) {
            newRules[classe].quotas[opt.toUpperCase()] = parseInt(val) || 0;
          }
        });
      }
    });
    
    // Mettre √† jour l'√©tat
    STATE.rules = newRules;
    
    // Sauvegarder en backend
    try {
      const result = await gsRun('updateStructureRules', newRules);
      if (result.success) {
        toast('R√®gles mises √† jour avec succ√®s', 'success');
        closeRulesModal();
      } else {
        toast('Erreur lors de la mise √† jour des r√®gles', 'error');
      }
    } catch (error) {
      console.error('Erreur:', error);
      toast('Erreur lors de la mise √† jour des r√®gles', 'error');
    }
  }
  
  // ========== MISE √Ä JOUR INTELLIGENTE DU PANEAU DES STATISTIQUES ==========
// (ANCIENNE VERSION SUPPRIM√âE - REMPLAC√âE PAR LA VERSION PROT√âG√âE)

// ========== GRAPHIQUES ==========
function initCharts() {
    console.log('üé® Initialisation des graphiques...');
    const statsContent = document.getElementById('statsContent');
    
    // HTML COMPLET avec tous les graphiques existants + nouveaux
    statsContent.innerHTML = `
      <div class="mb-2">
        <div class="flex gap-2 mb-2">
          <button onclick="switchChart('COM')" class="px-3 py-1 text-xs rounded font-semibold bg-green-500 text-white" id="btnCOM">COM</button>
          <button onclick="switchChart('TRA')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnTRA">TRA</button>
          <button onclick="switchChart('PART')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnPART">PART</button>
          <button onclick="switchChart('ABS')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnABS">ABS</button>
        </div>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">Distribution - <span id="scoreType">Comportement</span></h3>
        <canvas id="chartStacked" style="max-height: 150px;"></canvas>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">Moyennes par classe</h3>
        <canvas id="chartDetailed" style="max-height: 150px;"></canvas>
      </div>
      
      <div class="grid grid-cols-2 gap-2">
        <div class="chart-container" style="padding: 10px;">
          <h3 class="chart-title text-sm">R√©partition LV2</h3>
          <canvas id="chartLV2" style="max-height: 120px;"></canvas>
        </div>
        
        <div class="chart-container" style="padding: 10px;">
          <h3 class="chart-title text-sm">Options</h3>
          <canvas id="chartOptions" style="max-height: 120px;"></canvas>
        </div>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-top: 10px;">
        <h3 class="chart-title text-sm">Statistiques globales</h3>
        <div id="globalStats" class="text-xs"></div>
      </div>
      
      <!-- ========== NOUVEAUX AJOUTS EN BAS ========== -->
      
      <!-- M√©triques globales -->
  <div class="grid grid-cols-4 gap-3 mb-4 mt-4">
    <div class="stats-metric">
      <div class="metric-value" id="totalStudentsMetric">0</div>
      <div class="metric-label">√âl√®ves</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="genderBalanceMetric">50% F</div>
      <div class="metric-label">Ratio Filles</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="avgClassSizeMetric">0</div>
      <div class="metric-label">Moy/Classe</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="conformityScoreMetric">‚úÖ OK</div>
      <div class="metric-label">Probl√®mes</div>
    </div>
  </div>
      
      <!-- Nouveau graphique LV2 d√©taill√© -->
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">
          <i class="fas fa-language text-purple-500"></i>
          R√©partition LV2 par Classe
        </h3>
        <canvas id="chartLV2Details" style="max-height: 180px;"></canvas>
      </div>
    `;
    
    // Chart 1 : Distribution empil√©e par classe
    const ctx1 = document.getElementById('chartStacked').getContext('2d');
    chartCommunication = new Chart(ctx1, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          { label: '1', data: [], backgroundColor: '#dc2626', stack: 'Stack 0' },
          { label: '2', data: [], backgroundColor: '#fbbf24', stack: 'Stack 0' },
          { label: '3', data: [], backgroundColor: '#22c55e', stack: 'Stack 0' },
          { label: '4', data: [], backgroundColor: '#15803d', stack: 'Stack 0' }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { 
            stacked: true,
            ticks: { font: { size: 10 } }
          },
          y: { 
            stacked: true,
            beginAtZero: true,
            ticks: { font: { size: 10 } }
          }
        },
        plugins: {
          legend: { 
            display: true,
            position: 'right',
            labels: { 
              boxWidth: 12,
              font: { size: 10 }
            }
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                return `Score ${context.datasetIndex + 1}: ${context.parsed.y}`;
              }
            }
          }
        }
      }
    });
    
    // Chart 2 : Distribution par crit√®res
    const ctx2 = document.getElementById('chartDetailed').getContext('2d');
    chartDistribution = new Chart(ctx2, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          { label: 'COM', data: [], backgroundColor: '#10b981' },
          { label: 'TRA', data: [], backgroundColor: '#3b82f6' },
          { label: 'PART', data: [], backgroundColor: '#f59e0b' },
          { label: 'ABS', data: [], backgroundColor: '#ef4444' }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { ticks: { font: { size: 10 } } },
          y: { 
            beginAtZero: true,
            max: 4,
            ticks: { font: { size: 10 } }
          }
        },
        plugins: {
          legend: { 
            position: 'bottom',
            labels: { 
              boxWidth: 10,
              font: { size: 10 }
            }
          }
        }
      }
    });
    
    // Chart 3 : Distribution LV2
    const ctx3 = document.getElementById('chartLV2').getContext('2d');
    chartLV2 = new Chart(ctx3, {
      type: 'doughnut',
      data: {
        labels: [],
        datasets: [{
          data: [],
          backgroundColor: ['#dc2626', '#059669', '#2563eb', '#7c3aed', '#d97706']
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { 
            position: 'bottom',
            labels: { 
              boxWidth: 10,
              font: { size: 10 }
            }
          }
        }
      }
    });
    
    // Chart 4 : Distribution Options
    const ctx4 = document.getElementById('chartOptions').getContext('2d');
    chartOptions = new Chart(ctx4, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [{
          label: '√âl√®ves',
          data: [],
          backgroundColor: '#8b5cf6'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        indexAxis: 'y',
        scales: {
          x: { 
            beginAtZero: true,
            ticks: { font: { size: 10 } }
          },
          y: { ticks: { font: { size: 10 } } }
        },
        plugins: {
          legend: { display: false }
        }
      }
    });
    
    // ========== NOUVEAU GRAPHIQUE LV2 D√âTAILL√â ==========
    window.chartLV2Details = null;
    const ctx5 = document.getElementById('chartLV2Details');
    if (ctx5) {
      window.chartLV2Details = new Chart(ctx5.getContext('2d'), {
        type: 'bar',
        data: {
          labels: [],
          datasets: []
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              stacked: true,
              ticks: { font: { size: 10 } }
            },
            y: { 
              stacked: true,
              beginAtZero: true,
              ticks: { font: { size: 10 } }
            }
          },
          plugins: {
            legend: { 
              position: 'bottom',
              labels: { 
                boxWidth: 12,
                font: { size: 10 }
              }
            }
          }
        }
      });
    }
    
    // Initialiser avec COM
    updateCharts('COM');
    console.log('‚úÖ Graphiques initialis√©s avec succ√®s');
  }
  
  // Variable locale pour le type de score actuel (comme dans la version qui fonctionne)
  let currentScoreType = 'COM';
  

  
  // Fonction pour changer de graphique
  window.switchChart = function(type) {
    currentScoreType = type;
    
    // Mettre √† jour les boutons
    ['COM', 'TRA', 'PART', 'ABS'].forEach(t => {
      const btn = document.getElementById(`btn${t}`);
      if (t === type) {
        btn.classList.remove('bg-gray-300');
        btn.classList.add('bg-green-500', 'text-white');
      } else {
        btn.classList.remove('bg-green-500', 'text-white');
        btn.classList.add('bg-gray-300');
      }
    });
    
    // Mettre √† jour le titre
    const titles = {
      'COM': 'Comportement',
      'TRA': 'Travail',
      'PART': 'Participation',
      'ABS': 'Absent√©isme'
    };
    document.getElementById('scoreType').textContent = titles[type];
    
    // Mettre √† jour les graphiques
    updateCharts(type);
  }
  
  function updateCharts(scoreType = null) {
    console.log('üö® updateCharts D√âBUT - scoreType:', scoreType);
    try {
      console.log('üìä updateCharts appel√©e avec scoreType:', scoreType);
      if (!scoreType) scoreType = currentScoreType;
      console.log('üìä ScoreType final:', scoreType);
    
    // Collecter les donn√©es par classe
    const dataByClass = {};
    const classes = [];
    const lv2Count = {};
    const optionCount = {};
    
    document.querySelectorAll('.class-column').forEach(column => {
      const classe = column.querySelector('.classe-name').textContent;
      classes.push(classe);
      
      // IMPORTANT: R√©cup√©rer les cartes ACTUELLES de cette colonne
      const cards = Array.from(column.querySelectorAll('.student-card'));
      
      dataByClass[classe] = {
        total: cards.length,
        scores: { 
          COM: [0,0,0,0], 
          TRA: [0,0,0,0], 
          PART: [0,0,0,0],
          ABS: [0,0,0,0]
        },
        averages: { COM: 0, TRA: 0, PART: 0, ABS: 0 }
      };
      
      // Calculer les scores pour chaque √©l√®ve ACTUELLEMENT dans cette classe
      cards.forEach(card => {
        const eleve = STATE.students[card.dataset.id];
        if (!eleve) return;
        
        // Compter les scores pour le graphique empil√©
        const scoreMap = {
          'COM': eleve.scores.COM,
          'TRA': eleve.scores.TRA,
          'PART': eleve.scores.PART,
          'ABS': eleve.scores.ABS
        };
        
        const score = scoreMap[scoreType];
        if (score > 0) {
          dataByClass[classe].scores[scoreType][score - 1]++;
        }

        // Calculer les moyennes pour tous les crit√®res
        if (eleve.scores.COM > 0) dataByClass[classe].averages.COM += eleve.scores.COM;
        if (eleve.scores.TRA > 0) dataByClass[classe].averages.TRA += eleve.scores.TRA;
        if (eleve.scores.PART > 0) dataByClass[classe].averages.PART += eleve.scores.PART;
        if (eleve.scores.ABS > 0) dataByClass[classe].averages.ABS += eleve.scores.ABS;
        
        // Compter LV2 et options
        if (eleve.lv2) {
          lv2Count[eleve.lv2] = (lv2Count[eleve.lv2] || 0) + 1;
        }
        if (eleve.opt) {
          optionCount[eleve.opt] = (optionCount[eleve.opt] || 0) + 1;
        }
      });
      
      // Calculer les moyennes
      const total = cards.length || 1;
      dataByClass[classe].averages.COM /= total;
      dataByClass[classe].averages.TRA /= total;
      dataByClass[classe].averages.PART /= total;
      dataByClass[classe].averages.ABS /= total;
    });
    
    // V√©rifier que les graphiques existent
    if (!chartCommunication || !chartDistribution || !chartLV2 || !chartOptions) {
      console.warn('Graphiques non initialis√©s');
      return;
    }
    
    // Mettre √† jour Chart 1 (Distribution empil√©e)
    const sortedClasses = classes.sort();
    chartCommunication.data.labels = sortedClasses;
    
    // Mettre √† jour Chart 1 (Distribution empil√©e)
    chartCommunication.data.labels = sortedClasses;
    
    // Mettre √† jour les datasets pour le score s√©lectionn√©
    for (let i = 0; i < 4; i++) {
      chartCommunication.data.datasets[i].data = sortedClasses.map(c => 
        dataByClass[c].scores[scoreType][i]
      );
    }
    
    // V√©rification de coh√©rence des longueurs
    console.assert(
      sortedClasses.length === chartCommunication.data.datasets[0].data.length,
      'üí• Incoh√©rence longueurs', sortedClasses.length, chartCommunication.data.datasets[0].data.length
    );
    
    // Mettre √† jour Chart 2 (Moyennes par crit√®re)
    chartDistribution.data.labels = sortedClasses;
    chartDistribution.data.datasets[0].data = sortedClasses.map(c => 
      Math.round(dataByClass[c].averages.COM * 100) / 100
    );
    chartDistribution.data.datasets[1].data = sortedClasses.map(c => 
      Math.round(dataByClass[c].averages.TRA * 100) / 100
    );
    chartDistribution.data.datasets[2].data = sortedClasses.map(c => 
      Math.round(dataByClass[c].averages.PART * 100) / 100
    );
    chartDistribution.data.datasets[3].data = sortedClasses.map(c => 
      Math.round(dataByClass[c].averages.ABS * 100) / 100
    );
    
    // Mettre √† jour Chart 3 (LV2)
    chartLV2.data.labels = Object.keys(lv2Count);
    chartLV2.data.datasets[0].data = Object.values(lv2Count);
    
    // Mettre √† jour Chart 4 (Options)
    chartOptions.data.labels = Object.keys(optionCount);
    chartOptions.data.datasets[0].data = Object.values(optionCount);
    
    // Statistiques globales
    let globalTotals = { eleves: 0, filles: 0, garcons: 0 };
    let globalScores = { COM: 0, TRA: 0, PART: 0, ABS: 0 };
    let scoreCounts = { COM: 0, TRA: 0, PART: 0, ABS: 0 };
    
    // Parcourir TOUTES les cartes actuellement affich√©es
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve) {
        globalTotals.eleves++;
        if (eleve.sexe === 'F') globalTotals.filles++;
        else globalTotals.garcons++;

        if (eleve.scores.COM > 0) { globalScores.COM += eleve.scores.COM; scoreCounts.COM++; }
        if (eleve.scores.TRA > 0) { globalScores.TRA += eleve.scores.TRA; scoreCounts.TRA++; }
        if (eleve.scores.PART > 0) { globalScores.PART += eleve.scores.PART; scoreCounts.PART++; }
        if (eleve.scores.ABS > 0) { globalScores.ABS += eleve.scores.ABS; scoreCounts.ABS++; }
      }
    });
    
    const globalStatsHtml = `
      <p><strong>Total √©l√®ves :</strong> ${globalTotals.eleves}</p>
      <p><strong>R√©partition :</strong> ${globalTotals.filles} filles (${Math.round(globalTotals.filles/globalTotals.eleves*100)}%) / ${globalTotals.garcons} gar√ßons (${Math.round(globalTotals.garcons/globalTotals.eleves*100)}%)</p>
      <p class="mt-2"><strong>Moyennes globales :</strong></p>
      <ul>
        <li>Comportement : ${scoreCounts.COM > 0 ? (globalScores.COM / scoreCounts.COM).toFixed(2) : 'N/A'}</li>
        <li>Travail : ${scoreCounts.TRA > 0 ? (globalScores.TRA / scoreCounts.TRA).toFixed(2) : 'N/A'}</li>
        <li>Participation : ${scoreCounts.PART > 0 ? (globalScores.PART / scoreCounts.PART).toFixed(2) : 'N/A'}</li>
        <li>Absences : ${scoreCounts.ABS > 0 ? (globalScores.ABS / scoreCounts.ABS).toFixed(2) : 'N/A'}</li>
      </ul>
    `;
    
    const globalStatsElement = document.getElementById('globalStats');
    if (globalStatsElement) {
      globalStatsElement.innerHTML = globalStatsHtml;
    }
    
    chartCommunication.update();
    chartDistribution.update();
    chartLV2.update();
    chartOptions.update();
    
    // Mettre √† jour les autres m√©triques
    updateNewMetrics();
    updateLV2Details();
    
    console.log('üìä Mise √† jour des graphiques termin√©e');
  } catch (error) {
    console.error('‚ùå Erreur dans updateCharts:', error);
  }
  console.log('üö® updateCharts FIN');
}

// --- PATCH unicit√© updateCharts ---------------------------------
if (typeof window.updateChartsRiche === 'undefined') {
  window.updateChartsRiche = updateCharts;   // on m√©morise la vraie
}
window.updateCharts = window.updateChartsRiche; // on √©crase l'ancienne
// ----------------------------------------------------------------

// Attacher updateCharts √† window
window.updateCharts = updateCharts;
  
  // CORRECTION PROBL√àME 5 : MODE SOMBRE
  function toggleDarkMode() {
    STATE.darkMode = !STATE.darkMode;
    document.body.classList.toggle('dark-mode');
    
    const btnDarkMode = document.getElementById('btnDarkMode');
    if (STATE.darkMode) {
      btnDarkMode.innerHTML = '<i class="fas fa-sun"></i>';
    } else {
      btnDarkMode.innerHTML = '<i class="fas fa-moon"></i>';
    }
    
    // Sauvegarder la pr√©f√©rence
    try {
      localStorage.setItem('darkMode', STATE.darkMode);
    } catch (e) {
      console.log('localStorage non disponible');
    }
    
    toast(STATE.darkMode ? 'Mode sombre activ√©' : 'Mode clair activ√©', 'info');
  }
  
  // CORRECTION PROBL√àME 6 : MODE ZOOM
  function toggleZoom() {
    STATE.zoomMode = !STATE.zoomMode;
    document.body.classList.toggle('zoom-cards');
    
    const btnZoom = document.getElementById('btnZoom');
    if (STATE.zoomMode) {
      btnZoom.innerHTML = '<i class="fas fa-search-minus"></i>';
      toast('Mode zoom activ√©', 'info');
    } else {
      btnZoom.innerHTML = '<i class="fas fa-search-plus"></i>';
      toast('Mode zoom d√©sactiv√©', 'info');
    }
  }
  
  // ========== PLEIN √âCRAN STATS ==========
  window.toggleFullscreenStats = function() {
    STATE.fullscreenStats = !STATE.fullscreenStats;
    const statsPanel = document.getElementById('statsPanel');
    
    if (STATE.fullscreenStats) {
      document.body.classList.add('fullscreen-stats');
      statsPanel.classList.remove('translate-x-full');
      
      // Optionnel : demander le plein √©cran natif
      if (statsPanel.requestFullscreen) {
        statsPanel.requestFullscreen();
      }
      
      const btnFullscreen = document.getElementById('btnFullscreen');
      if (btnFullscreen) btnFullscreen.innerHTML = '<i class="fas fa-compress"></i>';
    } else {
      document.body.classList.remove('fullscreen-stats');
      
      // Optionnel : sortir du plein √©cran natif
      if (document.fullscreenElement) {
        document.exitFullscreen();
      }
      
      const btnFullscreen = document.getElementById('btnFullscreen');
      if (btnFullscreen) btnFullscreen.innerHTML = '<i class="fas fa-expand"></i>';
    }
    
    // Forcer la mise √† jour des graphiques
    setTimeout(() => {
      if (chartCommunication) chartCommunication.resize();
      if (chartDistribution) chartDistribution.resize();
      if (chartLV2) chartLV2.resize();
      if (chartOptions) chartOptions.resize();
    }, 300);
  }
  
  // ========== MODE ANCR√â ==========
  function toggleAnchoredStats() {
    STATE.anchoredStats = !STATE.anchoredStats;
    const statsPanel = document.getElementById('statsPanel');
    
    if (STATE.anchoredStats) {
      statsPanel.classList.add('anchored');
      document.getElementById('btnAnchor').classList.add('active');
      toast('Panel statistiques ancr√©', 'info');
    } else {
      statsPanel.classList.remove('anchored');
      document.getElementById('btnAnchor').classList.remove('active');
      toast('Panel statistiques flottant', 'info');
    }
  }
  
  // ========== RACCOURCIS CLAVIER ==========
  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Ignorer si on est dans un input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      // Ctrl+Z : Annuler
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
      }
      
      // Ctrl+Y : Refaire
      if (e.ctrlKey && e.key === 'y') {
        e.preventDefault();
        redo();
      }
      
      // S : Mode swap
      if (e.key === 's' && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        toggleSwapMode();
      }
      
      // T : Statistiques
      if (e.key === 't' && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        document.getElementById('btnStats').click();
      }
      
      // D : Mode sombre
      if (e.key === 'd' && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        toggleDarkMode();
      }
      
      // F : Plein √©cran stats (si panel ouvert)
      if (e.key === 'f' && !e.ctrlKey && !e.altKey) {
        if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
          e.preventDefault();
          toggleFullscreenStats();
        }
      }
      
      // Ctrl+F : Recherche
      if (e.ctrlKey && e.key === 'f') {
        e.preventDefault();
        document.getElementById('search').focus();
      }
      
      // ? : Aide
      if (e.key === '?' || (e.shiftKey && e.key === '/')) {
        e.preventDefault();
        toggleKeyboardHelp();
      }
      
      // M : Ouvrir le modal de s√©lection de mode
      if (e.key === 'm' && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        openStartupModal();
      }
      
      // √âchap : Fermer les modals
      if (e.key === 'Escape') {
        // Fermer stats si ouvert
        if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
          const panel = document.getElementById('statsPanel');
          panel.classList.add('translate-x-full');
          
          setTimeout(() => {
            document.body.classList.remove('stats-open');
          }, 300);
        }
        
        // Fermer autres modals
        document.querySelectorAll('.modal:not(.hidden)').forEach(modal => {
          modal.classList.add('hidden');
        });
        
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('overlay').classList.remove('active');
      }
    });
  }
  
  // CORRECTION PROBL√àME 7 : RACCOURCIS CLAVIER
  function toggleKeyboardHelp() {
    const help = document.getElementById('keyboardShortcuts');
    help.classList.toggle('hidden');
    
    if (!help.classList.contains('hidden')) {
      toast('Raccourcis clavier affich√©s', 'info');
    }
  }
  
  // ========== MAPPAGE DES BOUTONS ==========
  function setupEventListeners() {
    // S√©curiser tous les addEventListener avec des v√©rifications
    const btnRefresh = document.getElementById('btnRefresh');
    const btnSwap = document.getElementById('btnSwap');
    const btnUndo = document.getElementById('btnUndo');
    const btnRedo = document.getElementById('btnRedo');
    const btnAdmin = document.getElementById('btnAdmin');
    const btnSimpleView = document.getElementById('btnSimpleView');
    const btnStats = document.getElementById('btnStats');
    const btnExport = document.getElementById('btnExport');
    const btnSaveWIP = document.getElementById('btnSaveWIP');
    const btnFinalize = document.getElementById('btnFinalize');
    const btnEditRules = document.getElementById('btnEditRules');
    const btnDarkMode = document.getElementById('btnDarkMode');
    const btnZoom = document.getElementById('btnZoom');
    const btnHelp = document.getElementById('btnHelp');
    const closeStats = document.getElementById('closeStats');
    const btnFullscreen = document.getElementById('btnFullscreenMode');
    const btnAnchor = document.getElementById('btnAnchor');

    // Bouton rafra√Æchir
    if (btnRefresh) btnRefresh.addEventListener('click', attemptRefresh);

    // Bouton SWAP dans le header
    const btnSwapMain = document.getElementById('btnSwapMain');
    if (btnSwapMain) btnSwapMain.addEventListener('click', toggleSwapMode);

    // NOUVELLE FONCTION DE SAUVEGARDE AVEC PROGRESSION
    async function lancerSauvegardeAvecProgression(saveFunctionName, buttonElement, options = {}) {
      const { title = 'SAUVEGARDE EN COURS...', successMessage = 'Sauvegarde r√©ussie', progressive = true } = options;

      if (!window.saveProgressManager) {
        console.error('SaveProgressManager non trouv√© !');
        toast('Erreur : composant de progression manquant.', 'error');
        return;
      }

      // D√©sactiver le bouton
      if (buttonElement) buttonElement.disabled = true;

      // D√©marrer la barre de progression
      window.saveProgressManager.start();
      const header = document.querySelector('#saveProgressBar .save-progress-header span');
      if(header) header.textContent = title;

      try {
        // √âtape 1: Pr√©paration (10%)
        window.saveProgressManager.updateProgress(10, 'step1');
        const disposition = exportDisposition();

        if (!disposition || Object.keys(disposition).length === 0) {
          throw new Error('Aucune classe √† sauvegarder');
        }

        window.saveProgressManager.updateProgress(20, 'step2');
        await new Promise(resolve => setTimeout(resolve, 200));

        // ‚úÖ SAUVEGARDE PROGRESSIVE CLASSE PAR CLASSE (√©vite les timeouts)
        if (progressive && saveFunctionName === 'saveElevesCache') {
          const classes = Object.keys(disposition);
          const totalClasses = classes.length;
          let successCount = 0;
          const errors = [];

          console.log(`üì¶ Sauvegarde progressive de ${totalClasses} classe(s)...`);

          for (let i = 0; i < totalClasses; i++) {
            const classe = classes[i];
            const classMap = { [classe]: disposition[classe] };

            // Mettre √† jour la progression (20% √† 90%)
            const progress = 20 + ((i / totalClasses) * 70);
            window.saveProgressManager.updateProgress(progress, 'step3');

            // Mise √† jour du titre avec le nom de la classe en cours
            if(header) header.innerHTML = `<i class="fas fa-save mr-2"></i>${title} - ${classe} (${i+1}/${totalClasses})`;

            try {
              // ‚úÖ Sauvegarder UNE classe √† la fois
              const result = await gsRun(saveFunctionName, classMap, STATE.currentMode);

              if (!result || !result.success) {
                errors.push(`‚ùå ${classe}: ${result?.message || 'Erreur inconnue'}`);
                console.error(`‚ùå √âchec sauvegarde ${classe}:`, result);
              } else {
                successCount++;
                console.log(`‚úÖ ${classe} sauvegard√©e (${successCount}/${totalClasses})`);
              }
            } catch (err) {
              errors.push(`‚ùå ${classe}: ${err.message}`);
              console.error(`‚ùå Exception sauvegarde ${classe}:`, err);
            }

            // Petit d√©lai pour √©viter les timeouts cons√©cutifs
            await new Promise(resolve => setTimeout(resolve, 100));
          }

          // Finalisation (100%)
          window.saveProgressManager.updateProgress(100, 'step4');

          if (successCount === totalClasses) {
            window.saveProgressManager.complete(true);
            toast(`‚úÖ ${successCount} classe(s) sauvegard√©e(s) avec succ√®s !`, 'success');
          } else if (successCount > 0) {
            window.saveProgressManager.complete(true);
            toast(`‚ö†Ô∏è ${successCount}/${totalClasses} classe(s) sauvegard√©e(s). Erreurs: ${errors.join(', ')}`, 'warning');
            console.warn('Erreurs de sauvegarde:', errors);
          } else {
            throw new Error('Aucune classe sauvegard√©e: ' + errors.join(', '));
          }

        } else {
          // ‚úÖ SAUVEGARDE CLASSIQUE (pour finalizeClasses et autres)
          window.saveProgressManager.updateProgress(50, 'step2');
          await new Promise(resolve => setTimeout(resolve, 300));

          window.saveProgressManager.updateProgress(75, 'step3');
          const result = await gsRun(saveFunctionName, disposition, STATE.currentMode);

          if (!result || !result.success) {
            throw new Error(result?.message || 'Une erreur est survenue sur le serveur.');
          }

          window.saveProgressManager.updateProgress(100, 'step4');
          window.saveProgressManager.complete(true);
          toast(result.message || successMessage, 'success');
        }

      } catch (error) {
        console.error('Erreur lors de la sauvegarde avec progression:', error);
        toast(error.message, 'error');
        window.saveProgressManager.complete(false);
      } finally {
        // R√©activer le bouton
        if (buttonElement) buttonElement.disabled = false;
      }
    }

    // Bouton BROUILLON - Sauvegarde manuelle sur CACHE
    if (btnSaveWIP) btnSaveWIP.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      lancerSauvegardeAvecProgression('saveElevesCache', e.currentTarget, {
        title: 'Sauvegarde Brouillon (CACHE)...',
        successMessage: 'Brouillon sauvegard√© avec succ√®s !'
      });
    });

    // Bouton FINALISER - Cr√©ation des classes d√©finitives
    if (btnFinalize) btnFinalize.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!confirm('‚úÖ Cr√©er les classes finales d√©finitives ? Cette action est irr√©versible.')) return;
      
      lancerSauvegardeAvecProgression('finalizeClasses', e.currentTarget, {
        title: 'Finalisation des classes...',
        successMessage: 'Classes finalis√©es avec succ√®s !'
      });
    });

    if (btnUndo) btnUndo.addEventListener('click', undo);
    if (btnRedo) btnRedo.addEventListener('click', redo);
    if (btnAdmin) btnAdmin.addEventListener('click', toggleAdminMode);

    // Dropdown s√©lecteur de vue
    const viewModeSelect = document.getElementById('viewModeSelect');
    if (viewModeSelect) {
      // Initialiser la valeur du select selon le mode actuel
      viewModeSelect.value = STATE.viewMode;

      // Event listener pour changement de vue
      viewModeSelect.addEventListener('change', (e) => {
        STATE.viewMode = e.target.value;
        localStorage.setItem('viewMode', STATE.viewMode);

        // Mettre √† jour les classes body
        document.body.classList.remove('simple-view', 'essential-view');
        if (STATE.viewMode === 'simple') {
          document.body.classList.add('simple-view');
        } else if (STATE.viewMode === 'essential') {
          document.body.classList.add('essential-view');
        }

        // Recr√©er toutes les cartes pour appliquer la nouvelle vue
        document.querySelectorAll('.droppable-zone').forEach(zone => {
          const ids = Array.from(zone.querySelectorAll('.student-card')).map(c => c.dataset.id);
          zone.innerHTML = '';
          ids.forEach(id => {
            const eleve = STATE.students[id];
            if (eleve) {
              zone.appendChild(createStudentCard(eleve));
            }
          });
        });

        // Ajuster tailles si mode simple
        if (STATE.viewMode === 'simple') {
          setTimeout(() => {
            document.querySelectorAll('.droppable-zone').forEach(zone => {
              adjustSimpleNamesFontSize(zone);
            });
          }, 50);
        }

        toast(`Mode ${e.target.options[e.target.selectedIndex].text}`, 'info');
      });

      // Appliquer la classe body appropri√©e au chargement
      if (STATE.viewMode === 'simple') {
        document.body.classList.add('simple-view');
      } else if (STATE.viewMode === 'essential') {
        document.body.classList.add('essential-view');
      }
    }

    // ========== GESTION DES BADGES SEXE ET FOND BLANC ==========
    const showGenderBadges = document.getElementById('showGenderBadges');
    const whiteBackground = document.getElementById('whiteBackground');

    // Charger les pr√©f√©rences depuis localStorage
    const genderBadgesEnabled = localStorage.getItem('showGenderBadges') === 'true';
    const whiteBgEnabled = localStorage.getItem('whiteBackground') === 'true';

    if (showGenderBadges) {
      showGenderBadges.checked = genderBadgesEnabled;
      if (genderBadgesEnabled) {
        document.body.classList.add('gender-badges');
      }

      showGenderBadges.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        localStorage.setItem('showGenderBadges', isChecked);

        if (isChecked) {
          document.body.classList.add('gender-badges');
          toast('Badges sexe activ√©s', 'success');
        } else {
          document.body.classList.remove('gender-badges');
          toast('Badges sexe d√©sactiv√©s', 'info');
        }
      });
    }

    if (whiteBackground) {
      whiteBackground.checked = whiteBgEnabled;
      if (whiteBgEnabled) {
        document.body.classList.add('white-bg');
      }

      whiteBackground.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        localStorage.setItem('whiteBackground', isChecked);

        if (isChecked) {
          document.body.classList.add('white-bg');
          toast('Fond blanc activ√©', 'success');
        } else {
          document.body.classList.remove('white-bg');
          toast('Fond blanc d√©sactiv√©', 'info');
        }
      });
    }

    // CORRECTION PROBL√àME 4 : Stats sans overlay bloquant
    if (btnStats) btnStats.addEventListener('click', () => {
      const panel = document.getElementById('statsPanel');

      // Animation synchronis√©e
      requestAnimationFrame(() => {
        // 1. D√©finir la largeur du panneau AVANT de l'afficher
        const panelWidth = 600; // Largeur par d√©faut
        document.documentElement.style.setProperty('--stats-width', panelWidth + 'px');

        // 2. Ajouter la classe pour pr√©parer la grille
        document.body.classList.add('stats-open');

        // 3. Afficher le panneau avec animation
        setTimeout(() => {
          panel.classList.remove('translate-x-full');
          // Mettre √† jour aria-expanded
          btnStats.setAttribute('aria-expanded', 'true');

          // Initialiser les graphiques si pas encore fait
          if (!chartCommunication || !chartDistribution || !chartLV2 || !chartOptions) {
            if (typeof initCharts === 'function') {
              initCharts();
            }
          }

          updateCharts();
        }, 50);
      });
    });
    
    // Export
    if (btnExport) btnExport.addEventListener('click', () => {
      document.getElementById('exportModal').classList.remove('hidden');
      document.getElementById('overlay').classList.remove('hidden');
      document.getElementById('overlay').classList.add('active');
    });

    // √âdition des r√®gles
    if (btnEditRules) btnEditRules.addEventListener('click', openRulesModal);
    
    // Mode sombre
    if (btnDarkMode) btnDarkMode.addEventListener('click', toggleDarkMode);
    
    // Zoom
    if (btnZoom) btnZoom.addEventListener('click', toggleZoom);
    
    // Aide
    if (btnHelp) btnHelp.addEventListener('click', toggleKeyboardHelp);
  
    // Fermeture du panneau statistiques
    if (closeStats) closeStats.addEventListener('click', () => {
      const panel = document.getElementById('statsPanel');
      panel.classList.add('translate-x-full');
      // Mettre √† jour aria-expanded
      const btnStats = document.getElementById('btnStats');
      if (btnStats) btnStats.setAttribute('aria-expanded', 'false');

      // Attendre la fin de l'animation avant de restaurer la grille
      setTimeout(() => {
        document.body.classList.remove('stats-open');
      }, 300);
    });
  
    // Boutons statistiques avanc√©es
    if (btnFullscreen) btnFullscreen.addEventListener('click', toggleFullscreenStats);
    if (btnAnchor) btnAnchor.addEventListener('click', toggleAnchoredStats);
    
    // Rendre le panel stats redimensionnable
    makeResizable(document.getElementById('statsPanel'));
    
    // Configurer la recherche
    setupSearch();
  }
  
  // ========== PANEL REDIMENSIONNABLE ==========
  function makeResizable(element) {
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    
    const handle = document.createElement('div');
    handle.style.cssText = `
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: ew-resize;
      background: transparent;
    `;
    
    element.appendChild(handle);
    
    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = element.offsetWidth;
      document.body.style.cursor = 'ew-resize';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      
      const diff = startX - e.clientX;
      const newWidth = Math.min(Math.max(400, startWidth + diff), window.innerWidth * 0.8);
      element.style.width = newWidth + 'px';
      
      // Mettre √† jour la variable CSS pour adapter la grille
      if (document.body.classList.contains('stats-open')) {
        document.documentElement.style.setProperty('--stats-width', newWidth + 'px');
      }
    });
    
    document.addEventListener('mouseup', () => {
      isResizing = false;
      document.body.style.cursor = '';
    });
  }
  
    
// Attacher les fonctions globales √† window
window.openStartupModal = openStartupModal;
window.restoreCache = restoreCache;
window.checkCache = checkCache;
window.showModeBadge = showModeBadge;
window.stopAutoSave = stopAutoSave;
window.startAutoSave = startAutoSave;
window.showErrorState = showErrorState;
window.setupEventListeners = setupEventListeners;
window.setupKeyboardShortcuts = setupKeyboardShortcuts;
window.updateAllColumnStats = updateAllColumnStats;
window.updateAdvancedStats = updateAdvancedStats;
window.toast = toast;
  
  // =======================================================
  // 3. D√âMARRAGE FINAL
  // =======================================================
  
  // --- Event listeners pour le modal de d√©marrage ---
  const modal = document.getElementById('startupModal');
  const badge = document.getElementById('modeBadge');
  const closeBtn = document.getElementById('closeStartupModal');
  const btnRestore = document.getElementById('btnRestoreCache');
  
  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.classList.add('hidden'));
  }
  
  if (badge) {
    badge.addEventListener('dblclick', () => openStartupModal({ force: true }));
  }
  
  if (modal) {
    modal.querySelectorAll('button[data-mode]').forEach(btn => {
      btn.addEventListener('click', async e => { // Notez "async"
        const mode = e.currentTarget.dataset.mode;

        if ((mode === 'PREVIOUS' || mode === 'FIN') && !STATE.adminMode) {
          const password = prompt('Veuillez entrer le mot de passe administrateur :', '');
          if (password === null) return; // Annul√© par l'utilisateur

          try {
            const result = await gsRun('verifierMotDePasseAdmin', password);
            if (!result || !result.success) {
              alert('Mot de passe incorrect.');
              return;
            }
            STATE.adminMode = true;
          } catch (err) {
            alert('Erreur lors de la v√©rification du mot de passe.');
            return;
          }
        }

        localStorage.setItem('mode-selection', mode);
        modal.classList.add('hidden');
        initRepartitionApp();
      });
    });
  }
  
  if(btnRestore) {
    btnRestore.addEventListener('click', () => {
        restoreCache();
        modal.classList.add('hidden');
    });
  }
  
  // Branche les √©couteurs d'√©v√©nements principaux
  setupEventListeners(); 
  setupKeyboardShortcuts();
  
  // ========== NOUVELLES FONCTIONNALIT√âS ==========
  
  // Variable globale pour le filtre actif
  let activeFilter = 'all';
  let focusedColumn = null;

  // Fonction de filtrage rapide
  function applyQuickFilter(filter) {
    activeFilter = filter;

    // Mettre √† jour les boutons
    document.querySelectorAll('.filter-btn, .filter-btn-compact').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.filter === filter);
    });

    // Appliquer le filtre
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (!eleve) return;

      let match = false;

      switch (filter) {
        case 'all':
          match = true;
          break;
        case 'PERMUT':
        case 'FIXE':
          match = eleve.mobilite === filter;
          break;
        case 'ESP':
        case 'ITA':
        case 'ALL':
          match = eleve.lv2 === filter;
          break;
        case 'D':
          match = !!eleve.disso;
          break;
        case 'A':
          match = !!eleve.asso;
          break;
      }

      card.classList.toggle('filtered-out', !match);
    });

    // Afficher un message
    if (filter === 'all') {
      toast('Tous les √©l√®ves affich√©s', 'info');
    } else {
      const filtered = document.querySelectorAll('.student-card:not(.filtered-out)').length;
      toast(`${filtered} √©l√®ve(s) avec filtre ${filter}`, 'info');
    }
  }

  // Fonction d'export image
  window.exportAsImage = async function() {
    toast('G√©n√©ration de l\'image en cours...', 'info');
    
    try {
      const board = document.getElementById('board');
      const originalStyle = board.style.cssText;
      
      board.style.width = '1920px';
      board.style.padding = '20px';
      board.style.background = '#ffffff';
      
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const canvas = await html2canvas(board, {
        backgroundColor: '#ffffff',
        scale: 2,
        logging: false,
        useCORS: true,
        width: 1920,
        height: board.scrollHeight
      });
      
      board.style.cssText = originalStyle;
      
      const link = document.createElement('a');
      const niveau = STATE.niveau?.replace('¬∞', 'e') || 'classes';
      link.download = `repartition_${niveau}_${new Date().toISOString().split('T')[0]}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
      
      toast('Image export√©e avec succ√®s', 'success');
    } catch (error) {
      console.error('Erreur export image:', error);
      toast('Erreur lors de l\'export de l\'image', 'error');
    }
  };

  // Am√©liorer le syst√®me d'historique existant
  function addToHistory(action) {
    action.timestamp = new Date().toISOString();
    
    if (action.eleveId) {
      const eleve = STATE.students[action.eleveId];
      action.eleveName = eleve ? `${eleve.nom} ${eleve.prenom}` : 'Inconnu';
    }
    
    STATE.history.push(action);
    updateHistoryPanel();
  }

  window.toggleHistoryPanel = function() {
    const panel = document.getElementById('historyPanel');
    panel.classList.toggle('open');
  };

  // SUPPRIM√â - Premi√®re version de updateHistoryPanel
  // Remplac√©e par la version compl√®te plus bas

  function revertToPoint(index) {
    if (confirm(`Revenir √† cet √©tat ? (${STATE.history.length - index - 1} actions seront annul√©es)`)) {
      while (STATE.history.length > index + 1) {
        undo();
      }
      updateHistoryPanel();
    }
  }

  // Mode focus
  function enableFocusMode() {
    document.querySelectorAll('.class-column').forEach(column => {
      column.addEventListener('dblclick', () => {
        focusOnClass(column);
      });
    });
  }

  function focusOnClass(column) {
    if (focusedColumn) return;
    
    focusedColumn = column;
    
    const overlay = document.createElement('div');
    overlay.className = 'focus-overlay';
    document.body.appendChild(overlay);
    
    const hint = document.createElement('div');
    hint.className = 'exit-focus-hint';
    hint.innerHTML = 'Appuyez sur ESC pour sortir';
    document.body.appendChild(hint);
    
    column.classList.add('focused-column');
    document.body.style.overflow = 'hidden';
    
    function exitFocus(e) {
      if (e.key === 'Escape') {
        column.classList.remove('focused-column');
        overlay.remove();
        hint.remove();
        document.body.style.overflow = '';
        focusedColumn = null;
        document.removeEventListener('keydown', exitFocus);
      }
    }
    
    document.addEventListener('keydown', exitFocus);
    
    overlay.onclick = () => {
      const event = new KeyboardEvent('keydown', { key: 'Escape' });
      document.dispatchEvent(event);
    };
  }

  // Syst√®me de bookmarks
  window.toggleBookmarksMenu = function() {
    const menu = document.getElementById('bookmarksMenu');
    menu.classList.toggle('open');
    updateBookmarksMenu();
  };

  window.saveAsBookmark = function() {
    const name = prompt('Nom du favori :');
    if (!name) return;
    
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    bookmarks[name] = {
      date: new Date().toISOString(),
      disposition: exportDisposition(),
      mode: STATE.currentMode,
      stats: {
        total: Object.keys(STATE.students).length,
        classes: document.querySelectorAll('.class-column').length,
        niveau: STATE.niveau
      }
    };
    
    localStorage.setItem('repartition-bookmarks', JSON.stringify(bookmarks));
    updateBookmarksMenu();
    toast(`Favori "${name}" sauvegard√©`, 'success');
  };

  window.loadBookmark = function(name) {
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    const bookmark = bookmarks[name];
    
    if (!bookmark) return;
    
    if (!confirm(`Charger le favori "${name}" ? Cela remplacera la disposition actuelle.`)) {
      return;
    }
    
    Object.entries(bookmark.disposition).forEach(([classe, ids]) => {
      const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!zone) return;
      
      zone.innerHTML = '';
      
      ids.forEach(id => {
        const card = document.querySelector(`.student-card[data-id="${id}"]`);
        if (card) zone.appendChild(card);
      });
    });
    
    updateAllColumnStats();
    toast(`Favori "${name}" charg√©`, 'success');
  };

  window.deleteBookmark = function(name) {
    if (!confirm(`Supprimer le favori "${name}" ?`)) return;
    
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    delete bookmarks[name];
    localStorage.setItem('repartition-bookmarks', JSON.stringify(bookmarks));
    
    updateBookmarksMenu();
    toast(`Favori "${name}" supprim√©`, 'info');
  };

  function updateBookmarksMenu() {
    const container = document.getElementById('bookmarksList');
    if (!container) return;
    
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    container.innerHTML = '';
    
    if (Object.keys(bookmarks).length === 0) {
      container.innerHTML = '<div class="p-4 text-center text-gray-500">Aucun favori enregistr√©</div>';
      return;
    }
    
    Object.entries(bookmarks).forEach(([name, data]) => {
      const item = document.createElement('div');
      item.className = 'bookmark-item';
      item.innerHTML = `
        <div class="bookmark-name">${name}</div>
        <div class="bookmark-meta">
          Sauvegard√© le ${new Date(data.date).toLocaleDateString('fr-FR')}
          - ${data.stats.total} √©l√®ves
        </div>
        <div class="bookmark-actions">
          <button class="btn btn-sm btn-primary" onclick="loadBookmark('${name}')">
            <i class="fas fa-download"></i> Charger
          </button>
          <button class="btn btn-sm btn-secondary" onclick="deleteBookmark('${name}')">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      `;
      container.appendChild(item);
    });
  }

  // Initialiser les nouvelles fonctionnalit√©s
  enableFocusMode();
  updateHistoryPanel();

  // Fermer les menus au clic externe
  document.addEventListener('click', (e) => {
    if (!e.target.closest('#btnBookmarks') && !e.target.closest('#bookmarksMenu')) {
      document.getElementById('bookmarksMenu')?.classList.remove('open');
    }
  });

  // Ajouter les event listeners pour les nouveaux boutons
  const btnHistory = document.getElementById('btnHistory');
  const btnBookmarks = document.getElementById('btnBookmarks');
  
  if (btnHistory) btnHistory.addEventListener('click', toggleHistoryPanel);
  if (btnBookmarks) btnBookmarks.addEventListener('click', toggleBookmarksMenu);

  // Initialiser les filtres
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.addEventListener('click', () => applyQuickFilter(btn.dataset.filter));
  });
  
  // CORRECTION : TOUJOURS afficher le modal au d√©marrage
  // L'utilisateur doit pouvoir choisir √† chaque fois
  openStartupModal();

  // Gestion des menus d√©roulants fixes au clic
  (function() {
    function setupDropdown(wrapperId, btnId, dropdownId) {
      const wrapper = document.getElementById(wrapperId);
      const btn = document.getElementById(btnId);
      const dropdown = document.getElementById(dropdownId);
      if (!wrapper || !btn || !dropdown) return;
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        // Fermer tous les autres dropdowns
        document.querySelectorAll('.app-header .absolute').forEach(d => {
          if (d !== dropdown) {
            d.classList.add('hidden');
            d.setAttribute('aria-hidden', 'true');
            // Trouver le bouton associ√© et mettre √† jour aria-expanded
            const otherBtns = document.querySelectorAll('[aria-haspopup="menu"]');
            otherBtns.forEach(otherBtn => {
              if (otherBtn.nextElementSibling === d || (otherBtn.parentElement && otherBtn.parentElement.contains(d))) {
                otherBtn.setAttribute('aria-expanded', 'false');
              }
            });
          }
        });
        const isHidden = dropdown.classList.toggle('hidden');
        // Mettre √† jour les attributs ARIA
        btn.setAttribute('aria-expanded', !isHidden);
        dropdown.setAttribute('aria-hidden', isHidden);
      });
      // Emp√™cher la fermeture si on clique dans le menu
      dropdown.addEventListener('click', e => e.stopPropagation());
    }
    setupDropdown('settingsMenuWrapper', 'btnSettings', 'settingsDropdown');

    // Mapper les nouveaux boutons du menu Param√®tres aux fonctions existantes
    const settingsDropdown = document.getElementById('settingsDropdown');
    if (settingsDropdown) {
      // Section Affichage
      const menuDarkMode = document.getElementById('menuDarkMode');
      if (menuDarkMode) {
        menuDarkMode.addEventListener('click', () => {
          toggleDarkMode();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuZoom = document.getElementById('menuZoom');
      if (menuZoom) {
        menuZoom.addEventListener('click', () => {
          toggleZoom();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuFullscreen = document.getElementById('menuFullscreen');
      if (menuFullscreen) {
        menuFullscreen.addEventListener('click', () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
          settingsDropdown.classList.add('hidden');
        });
      }

      // Section Actions - Annuler/Refaire d√©j√† g√©r√©s par leurs ID existants (btnUndo, btnRedo)
      // Boutons Favoris, Optimiser, Contraintes, Filtres supprim√©s (non fonctionnels)

      // Section Donn√©es
      const menuImportScores = document.getElementById('menuImportScores');
      const btnImportScores = document.getElementById('btnImportScores');
      if (menuImportScores && btnImportScores) {
        menuImportScores.addEventListener('click', () => {
          btnImportScores.click();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuRules = document.getElementById('menuRules');
      const btnEditRules = document.getElementById('btnEditRules');
      if (menuRules && btnEditRules) {
        menuRules.addEventListener('click', () => {
          btnEditRules.click();
          settingsDropdown.classList.add('hidden');
        });
      }

      // Section Filtres
      const filterBtnsCompact = settingsDropdown.querySelectorAll('.filter-btn-compact');
      filterBtnsCompact.forEach(btn => {
        btn.addEventListener('click', () => {
          const filter = btn.dataset.filter;
          // Retirer la classe active de tous les boutons
          filterBtnsCompact.forEach(b => b.classList.remove('active'));
          // Ajouter la classe active au bouton cliqu√©
          btn.classList.add('active');
          // Appliquer le filtre en utilisant la fonction existante
          applyQuickFilter(filter);
          // Fermer le menu
          settingsDropdown.classList.add('hidden');
        });
      });

      // Section Aide - btnHelp et btnTutorial d√©j√† g√©r√©s par leurs ID existants
    }

    // Fermer tous les menus au clic ext√©rieur
    document.addEventListener('click', () => {
      document.querySelectorAll('.app-header .absolute').forEach(d => {
        d.classList.add('hidden');
        d.setAttribute('aria-hidden', 'true');
      });
      // Mettre √† jour aria-expanded pour tous les boutons de menu
      document.querySelectorAll('[aria-haspopup="menu"]').forEach(btn => {
        btn.setAttribute('aria-expanded', 'false');
      });
    });
  })();

}); // Fin du DOMContentLoaded

// =======================================================
// FONCTIONS GLOBALES SUPPLEMENTAIRES
// =======================================================

// ========== FONCTIONS POUR LES NOUVELLES M√âTRIQUES ==========
function updateNewMetrics() {
  // V√©rifier que les m√©triques sont pr√™tes dans le DOM
  const metricsReady = document.getElementById('totalStudentsMetric');
  if (!metricsReady) return; // panneau pas encore inject√©
  
  console.log('üî¢ Recalcul metrics - d√©but');
  
  // Total √©l√®ves (uniquement dans les vraies classes)
  let totalStudents = 0;
  let filles = 0;
  let totalClasses = 0;
  
  document.querySelectorAll('.class-column').forEach(column => {
    const className = column.querySelector('.classe-name').textContent;
    if (!isRealClass(className)) return;
    
    totalClasses++;
    column.querySelectorAll('.student-card').forEach(card => {
      const student = STATE.students[card.dataset.id];
      if (student) {
        totalStudents++;
        if (student.sexe === 'F') filles++;
      }
    });
  });
  
  console.log('üî¢ Recalcul metrics', {totalStudents, filles, totalClasses});
  
  const totalElement = document.getElementById('totalStudentsMetric');
  if (totalElement) {
    totalElement.textContent = totalStudents;
    console.log('üî¢ totalStudentsMetric mis √† jour:', totalStudents);
  } else {
    console.warn('‚ùì m√©trique manquante dans le DOM : totalStudentsMetric');
  }
  
  // Ratio filles
  const ratio = totalStudents > 0 ? Math.round((filles / totalStudents) * 100) : 0;
  const ratioElement = document.getElementById('genderBalanceMetric');
  if (ratioElement) {
    ratioElement.textContent = `${ratio}% F`;
    console.log('üî¢ genderBalanceMetric mis √† jour:', `${ratio}% F`);
  } else {
    console.warn('‚ùì m√©trique manquante dans le DOM : genderBalanceMetric');
  }
  
  // Moyenne par classe
  const avgClass = totalClasses > 0 ? Math.round(totalStudents / totalClasses) : 0;
  const avgElement = document.getElementById('avgClassSizeMetric');
  if (avgElement) {
    avgElement.textContent = avgClass;
    console.log('üî¢ avgClassSizeMetric mis √† jour:', avgClass);
  } else {
    console.warn('‚ùì m√©trique manquante dans le DOM : avgClassSizeMetric');
  }
  
  // Score de conformit√©
  const conformityElement = document.getElementById('conformityScoreMetric');
  if (conformityElement) {
    conformityElement.textContent = '‚úÖ OK';
    console.log('üî¢ conformityScoreMetric mis √† jour: ‚úÖ OK');
  } else {
    console.warn('‚ùì m√©trique manquante dans le DOM : conformityScoreMetric');
  }
  
  console.log('üî¢ Recalcul metrics - termin√©');
}

function updateLV2Details() {
  if (!window.chartLV2Details) return;
  
  const classes = Array.from(document.querySelectorAll('.class-column')).map(col => 
    col.querySelector('.classe-name').textContent
  ).sort();
  
  const lv2Types = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
  const colors = ['#dc2626', '#059669', '#2563eb', '#7c3aed', '#d97706'];
  
  window.chartLV2Details.data.labels = classes;
  window.chartLV2Details.data.datasets = lv2Types.map((lv2, index) => ({
    label: lv2,
    data: classes.map(classe => {
      const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!zone) return 0;
      return Array.from(zone.querySelectorAll('.student-card')).filter(card => {
        const eleve = STATE.students[card.dataset.id];
        return eleve && eleve.lv2 && eleve.lv2.toUpperCase() === lv2;
      }).length;
    }),
    backgroundColor: colors[index],
    stack: 'Stack 0'
  }));
  
  window.chartLV2Details.update();
}

function updateConformityGrid() {
  const grid = document.getElementById('conformityGrid');
  if (!grid) return;
  
  const classes = Array.from(document.querySelectorAll('.class-column')).map(col => 
    col.querySelector('.classe-name').textContent
  ).sort();
  
  let html = '';
  classes.forEach(classe => {
    const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
    if (!zone) return;
    
    const cards = Array.from(zone.querySelectorAll('.student-card'));
    const total = cards.length;
    const filles = cards.filter(card => {
      const eleve = STATE.students[card.dataset.id];
      return eleve && eleve.sexe === 'F';
    }).length;
    
    const ratio = total > 0 ? Math.round((filles / total) * 100) : 0;
    let status = 'conformity-undefined';
    let text = '?';
    
    if (ratio >= 40 && ratio <= 60) {
      status = 'conformity-ok';
      text = 'OK';
    } else if (ratio >= 30 && ratio <= 70) {
      status = 'conformity-warning';
      text = '!';
    } else {
      status = 'conformity-error';
      text = '‚úó';
    }
    
    html += `<div class="conformity-cell ${status}" title="${classe}: ${ratio}% filles">${text}</div>`;
  });
  
  grid.innerHTML = html;
}

function updateBalanceIndicators() {
  const container = document.getElementById('balanceIndicators');
  if (!container) return;
  
  const suggestions = [];
  
  // Analyser l'√©quilibre des sexes
  document.querySelectorAll('.class-column').forEach(column => {
    const classe = column.querySelector('.classe-name').textContent;
    const cards = Array.from(column.querySelectorAll('.student-card'));
    const total = cards.length;
    const filles = cards.filter(card => {
      const eleve = STATE.students[card.dataset.id];
      return eleve && eleve.sexe === 'F';
    }).length;
    
    const ratio = total > 0 ? Math.round((filles / total) * 100) : 0;
    
    if (ratio < 30) {
      suggestions.push({
        type: 'warning',
        message: `${classe}: Trop peu de filles (${ratio}%)`,
        icon: 'fa-exclamation-triangle'
      });
    } else if (ratio > 70) {
      suggestions.push({
        type: 'warning',
        message: `${classe}: Trop peu de gar√ßons (${100-ratio}%)`,
        icon: 'fa-exclamation-triangle'
      });
    }
  });
  
  if (suggestions.length === 0) {
    suggestions.push({
      type: 'success',
      message: '√âquilibre des sexes satisfaisant',
      icon: 'fa-check-circle'
    });
  }
  
  const html = suggestions.map(s => `
    <div class="indicator-card indicator-${s.type === 'success' ? 'good' : 'warning'}">
      <i class="fas ${s.icon} mr-2"></i>
      ${s.message}
    </div>
  `).join('');
  
  container.innerHTML = html;
}

// --- Responsive : recalculer √† chaque resize de la fen√™tre (avec debounce) ---
let resizeTimeout = null;
window.addEventListener('resize', () => {
  if (STATE.viewMode !== 'simple') return;
  if (resizeTimeout) clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    document.querySelectorAll('.droppable-zone').forEach(zone => adjustSimpleNamesFontSize(zone));
  }, 100);
});

// (FONCTION openStartupModal SUPPRIM√âE - DOUBLON)

// FONCTIONS MANQUANTES - √Ä ajouter dans le script principal

// 1. Gestion du mode sombre depuis localStorage
function initDarkMode() {
  try {
    if (typeof localStorage !== 'undefined') {
      const savedDarkMode = localStorage.getItem('darkMode') === 'true';
      if (savedDarkMode) {
        STATE.darkMode = true;
        document.body.classList.add('dark-mode');
        const btnDarkMode = document.getElementById('btnDarkMode');
        if (btnDarkMode) btnDarkMode.innerHTML = '<i class="fas fa-sun"></i>';
      }
    }
  } catch (e) {
    console.warn('Could not access localStorage for dark mode.', e);
  }
}

// 2. Tutoriel interactif
function showTutorial() {
  const steps = [
    { element: '#search', title: 'Recherche', text: 'Utilisez cette barre pour trouver rapidement un √©l√®ve par son nom.' },
    { element: '#btnFilters', title: 'Filtres', text: 'Filtrez les √©l√®ves par type (PERMUT, FIXE, LV2, etc.)' },
    { element: '.class-column:first-child', title: 'Classes', text: 'Glissez-d√©posez les √©l√®ves entre les classes. Double-clic pour mode focus.' },
    { element: '#btnSwap', title: 'Mode Swap', text: 'Utilisez ce mode pour √©changer facilement deux √©l√®ves.' },
    { element: '#btnStats', title: 'Statistiques', text: 'Consultez les graphiques et analyses d√©taill√©es.' }
  ];
  let currentStep = 0;
  function showStep(index) {
    if (index >= steps.length) { hideTutorial(); toast('Tutoriel termin√© ! Vous √™tes pr√™t √† utiliser l\'application.', 'success'); return; }
    const step = steps[index];
    const element = document.querySelector(step.element);
    if (!element) { currentStep++; showStep(currentStep); return; }
    const overlay = document.createElement('div');
    overlay.id = 'tutorialOverlay';
    overlay.className = 'fixed inset-0 bg-black bg-opacity-70 z-50';
    const bubble = document.createElement('div');
    bubble.className = 'absolute bg-white rounded-lg p-4 shadow-xl max-w-sm z-60';
    bubble.innerHTML = `<h3 class="font-bold text-lg mb-2">${step.title}</h3><p class="mb-4">${step.text}</p><div class="flex justify-between items-center"><span class="text-sm text-gray-500">${index + 1}/${steps.length}</span><div class="space-x-2"><button onclick="hideTutorial()" class="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300">Passer</button><button onclick="nextTutorialStep()" class="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600">${index === steps.length - 1 ? 'Terminer' : 'Suivant'}</button></div></div>`;
    const rect = element.getBoundingClientRect();
    bubble.style.top = (rect.bottom + 20) + 'px';
    bubble.style.left = Math.max(20, rect.left - 100) + 'px';
    element.style.position = 'relative';
    element.style.zIndex = '55';
    element.style.boxShadow = '0 0 0 4px #3b82f6, 0 0 0 8px rgba(59, 130, 246, 0.3)';
    element.style.borderRadius = '8px';
    overlay.appendChild(bubble);
    document.body.appendChild(overlay);
  }
  window.nextTutorialStep = function() { currentStep++; hideTutorial(); setTimeout(() => showStep(currentStep), 300); };
  window.hideTutorial = function() {
    document.getElementById('tutorialOverlay')?.remove();
    document.querySelectorAll('[style*="z-index"]').forEach(el => {
      el.style.position = '';
      el.style.zIndex = '';
      el.style.boxShadow = '';
      el.style.borderRadius = '';
    });
  };
  showStep(0);
}

// 3. Actualisation intelligente (d√©j√† pr√©sente mais toast am√©lior√©)
window.attemptRefresh = async function() {
  showSpinner();
  try {
    const currentMode = localStorage.getItem('mode-selection') || 'TEST';
    const success = await loadDataForMode(currentMode);
    if (success) {
      toast('Donn√©es actualis√©es avec succ√®s', 'success');
    } else {
      toast('√âchec de l\'actualisation', 'error');
    }
  } catch (error) {
    console.error('Erreur actualisation:', error);
    toast('Erreur lors de l\'actualisation', 'error');
  } finally {
    hideSpinner();
  }
}

// 4. Am√©lioration de la fonction de recherche
function enhanceSearch() {
  const searchInput = document.getElementById('search');
  let searchTimeout;
  if (!searchInput) return;
  searchInput.addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
      const term = e.target.value.toLowerCase().trim();
      STATE.searchTerm = term;
      let matchCount = 0;
      document.querySelectorAll('.student-card').forEach(card => {
        const nameEl = card.querySelector('.student-fullname, .student-simple-name');
        if (!nameEl) return;
        const fullName = nameEl.textContent.toLowerCase();
        const eleve = STATE.students[card.dataset.id];
        const searchText = [fullName, eleve?.lv2?.toLowerCase() || '', eleve?.opt?.toLowerCase() || '', eleve?.mobilite?.toLowerCase() || ''].join(' ');
        const match = !term || searchText.includes(term);
        card.style.display = match ? '' : 'none';
        card.classList.toggle('search-highlight', match && term);
        if (match) matchCount++;
      });
      if (term) {
        toast(`${matchCount} √©l√®ve(s) trouv√©(s)`, 'info');
      }
    }, 300);
  });
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'f') {
      e.preventDefault();
      searchInput.focus();
      searchInput.select();
    }
  });
}

// 5. Syst√®me de notifications persistantes
function createNotificationSystem() {
  if (!document.getElementById('notificationContainer')) {
    const container = document.createElement('div');
    container.id = 'notificationContainer';
    container.className = 'fixed top-20 right-4 z-50 space-y-2 max-w-sm';
    document.body.appendChild(container);
  }
}
function showPersistentNotification(message, type = 'info', duration = 5000) {
  createNotificationSystem();
  const container = document.getElementById('notificationContainer');
  const notification = document.createElement('div');
  const bgColors = { success: 'bg-green-500', error: 'bg-red-500', warning: 'bg-yellow-500', info: 'bg-blue-500' };
  const icons = { success: 'fa-check-circle', error: 'fa-exclamation-circle', warning: 'fa-exclamation-triangle', info: 'fa-info-circle' };
  notification.className = `${bgColors[type]} text-white p-3 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 flex items-center gap-2`;
  notification.innerHTML = `<i class="fas ${icons[type]}"></i><span class="flex-1">${message}</span><button onclick="this.parentElement.remove()" class="text-white hover:text-gray-200"><i class="fas fa-times"></i></button>`;
  container.appendChild(notification);
  setTimeout(() => { notification.classList.remove('translate-x-full'); }, 100);
  if (duration > 0) {
    setTimeout(() => { notification.classList.add('translate-x-full'); setTimeout(() => notification.remove(), 300); }, duration);
  }
}

// 6. Am√©lioration du syst√®me d'aide
function createContextualHelp() {
  const helpButton = document.getElementById('btnTutorial');
  if (helpButton) {
    helpButton.addEventListener('click', () => {
      const hasSeenTutorial = localStorage.getItem('hasSeenTutorial');
      if (!hasSeenTutorial) {
        localStorage.setItem('hasSeenTutorial', 'true');
      }
      showTutorial();
    });
  }
}

// 7. Gestion des pr√©f√©rences utilisateur
function saveUserPreferences() {
  const preferences = {
    viewMode: STATE.viewMode,
    darkMode: STATE.darkMode,
    lastFilter: activeFilter || 'all'
  };
  localStorage.setItem('userPreferences', JSON.stringify(preferences));
}
function loadUserPreferences() {
  try {
    const saved = localStorage.getItem('userPreferences');
    if (saved) {
      const prefs = JSON.parse(saved);
      // G√©rer l'ancienne propri√©t√© simpleView pour la compatibilit√©
      if (prefs.simpleView !== undefined && prefs.viewMode === undefined) {
        STATE.viewMode = prefs.simpleView ? 'simple' : 'complete';
        localStorage.setItem('viewMode', STATE.viewMode);
      }
      if (prefs.darkMode && !STATE.darkMode) { toggleDarkMode(); }
      if (prefs.lastFilter && prefs.lastFilter !== 'all') { setTimeout(() => applyQuickFilter(prefs.lastFilter), 1000); }
    }
  } catch (e) { console.warn('Erreur chargement pr√©f√©rences:', e); }
}

// 8. Fonction d'initialisation globale am√©lior√©e
function initializeEnhancements() {
  loadUserPreferences();
  initDarkMode();
  enhanceSearch();
  createContextualHelp();
  createNotificationSystem();
  window.addEventListener('beforeunload', saveUserPreferences);
  if (!localStorage.getItem('hasSeenTutorial')) {
    setTimeout(() => {
      if (confirm('Premi√®re visite ? Voulez-vous voir le tutoriel interactif ?')) {
        showTutorial();
      }
      localStorage.setItem('hasSeenTutorial', 'true');
    }, 2000);
  }
}
// ... existing code ...
// √Ä la fin du DOMContentLoaded, apr√®s setupEventListeners() et openStartupModal();
initializeEnhancements();
// ... existing code ...

// ========== PATCH DE CORRECTIONS CRITIQUES ==========

// 1. FIX: Historique timeline qui ne s'affiche pas
function addToHistory(action) {
  action.timestamp = new Date().toISOString();
  
  if (action.eleveId) {
    const eleve = STATE.students[action.eleveId];
    action.eleveName = eleve ? `${eleve.nom} ${eleve.prenom || ''}` : 'Inconnu';
  }
  
  // Ajouter l'action √† l'historique global
  if (!STATE.historyTimeline) STATE.historyTimeline = [];
  STATE.historyTimeline.push(action);
  
  // Mettre √† jour le panneau
  updateHistoryPanel();
}

function updateHistoryPanel() {
  const container = document.getElementById('historyTimeline');
  if (!container) return;
  
  container.innerHTML = '';
  
  // Utiliser historyTimeline au lieu de history
  const timeline = STATE.historyTimeline || [];
  
  timeline.slice().reverse().forEach((action, idx) => {
    const item = document.createElement('div');
    item.className = 'timeline-item';
    
    let actionText = '';
    let details = '';
    let icon = 'fa-question';
    let color = '#6b7280';
    
    switch (action.type) {
      case 'move':
        actionText = `D√©placement: ${action.eleveName || '√âl√®ve'}`;
        details = `${action.oldClasse} ‚Üí ${action.newClasse}`;
        icon = 'fa-arrow-right';
        color = '#3b82f6';
        break;
      case 'swap':
        const eleve1 = STATE.students[action.id1];
        const eleve2 = STATE.students[action.id2];
        actionText = `√âchange effectu√©`;
        details = `${eleve1?.nom || '√âl√®ve 1'} ‚Üî ${eleve2?.nom || '√âl√®ve 2'}`;
        icon = 'fa-exchange-alt';
        color = '#f59e0b';
        break;
    }
    
    item.innerHTML = `
      <div class="timeline-dot" style="background: ${color};">
        <i class="fas ${icon} text-xs"></i>
      </div>
      <div class="timeline-content">
        <div class="timeline-time">${new Date(action.timestamp).toLocaleTimeString('fr-FR')}</div>
        <div class="timeline-action">${actionText}</div>
        <div class="timeline-details">${details}</div>
      </div>
    `;
    
    container.appendChild(item);
  });
  
  // Afficher un message si vide
  if (timeline.length === 0) {
    container.innerHTML = '<div class="text-center text-gray-500 p-4">Aucune action enregistr√©e</div>';
  }
}

// Attacher updateHistoryPanel √† window
window.updateHistoryPanel = updateHistoryPanel;

// FIX 1: Historique qui ne persiste pas correctement
if (!STATE.historyTimeline) {
  STATE.historyTimeline = [];
}



// 4. FIX: Styles manquants pour la timeline
const timelineStyles = document.createElement('style');
timelineStyles.textContent = `
  .timeline-item {
    position: relative;
    padding-left: 2.5rem;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .timeline-item:hover {
    background: #f8fafc;
  }
  
  .timeline-item::before {
    content: '';
    position: absolute;
    left: 1.25rem;
    top: 2rem;
    bottom: -1rem;
    width: 2px;
    background: #e5e7eb;
  }
  
  .timeline-item:last-child::before {
    display: none;
  }
  
  .timeline-dot {
    position: absolute;
    left: 0.75rem;
    top: 0.75rem;
    width: 2rem;
    height: 2rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .timeline-content {
    padding: 0.5rem 0;
  }
  
  .timeline-time {
    font-size: 0.75rem;
    color: #6b7280;
    margin-bottom: 0.25rem;
  }
  
  .timeline-action {
    font-weight: 600;
    color: #1e293b;
    margin-bottom: 0.25rem;
  }
  
  .timeline-details {
    font-size: 0.875rem;
    color: #4b5563;
  }
`;
document.head.appendChild(timelineStyles);

// 5. FIX: Variable activeFilter non d√©finie globalement
window.activeFilter = 'all';

// 6. FIX: Fonction applyQuickFilter am√©lior√©e
window.applyQuickFilter = function(filter) {
  window.activeFilter = filter;
  
  // Mettre √† jour les boutons
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.filter === filter);
  });
  
  // Appliquer le filtre
  let visibleCount = 0;
  document.querySelectorAll('.student-card').forEach(card => {
    const eleve = STATE.students[card.dataset.id];
    if (!eleve) return;
    
    let match = false;
    
    switch (filter) {
      case 'all':
        match = true;
        break;
      case 'PERMUT':
      case 'FIXE':
        match = eleve.mobilite === filter;
        break;
      case 'ESP':
      case 'ITA':
      case 'ALL':
        match = eleve.lv2 === filter;
        break;
      case 'D':
        match = !!eleve.disso;
        break;
      case 'A':
        match = !!eleve.asso;
        break;
    }
    
    card.classList.toggle('filtered-out', !match);
    if (match) visibleCount++;
  });
  
  // Notification du r√©sultat
  if (filter !== 'all') {
    toast(`${visibleCount} √©l√®ve(s) avec filtre "${filter}"`, 'info');
  }
};

// 7. FIX: Meilleure gestion des tooltips
document.addEventListener('DOMContentLoaded', () => {
  // Ajouter des tooltips riches sur les badges
  document.addEventListener('mouseover', (e) => {
    if (e.target.classList.contains('mini-badge')) {
      const title = e.target.getAttribute('title');
      if (!title) return;
      
      // Cr√©er un tooltip personnalis√© si n√©cessaire
      const existingTooltip = document.querySelector('.custom-tooltip');
      if (existingTooltip) existingTooltip.remove();
      
      const tooltip = document.createElement('div');
      tooltip.className = 'custom-tooltip';
      tooltip.textContent = title;
      tooltip.style.cssText = `
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        z-index: 9999;
        pointer-events: none;
        white-space: nowrap;
      `;
      
      const rect = e.target.getBoundingClientRect();
      tooltip.style.left = rect.left + 'px';
      tooltip.style.top = (rect.bottom + 5) + 'px';
      
      document.body.appendChild(tooltip);
    }
  });
  
  document.addEventListener('mouseout', (e) => {
    if (e.target.classList.contains('mini-badge')) {
      document.querySelector('.custom-tooltip')?.remove();
    }
  });
});

// 8. FIX: Am√©lioration de la sauvegarde imm√©diate
window.saveImmediateCache = async function() {
  try {
    const disposition = exportDisposition();
    const cacheData = {
      date: new Date().toISOString(),
      disposition: disposition,
      mode: STATE.currentMode,
      filters: window.activeFilter,
      stats: {
        total: Object.keys(STATE.students).length,
        classes: document.querySelectorAll('.class-column').length
      }
    };
    
    // Sauvegarde locale avec compression
    localStorage.setItem('cache-data', JSON.stringify(cacheData));
    localStorage.setItem('cache-timestamp', new Date().toISOString());
    
    // Indicateur visuel de sauvegarde
    const saveIndicator = document.createElement('div');
    saveIndicator.className = 'fixed top-20 right-4 bg-green-500 text-white px-3 py-1 rounded-full text-sm';
    saveIndicator.innerHTML = '<i class="fas fa-check mr-1"></i> Sauvegard√©';
    document.body.appendChild(saveIndicator);
    
    setTimeout(() => saveIndicator.remove(), 2000);
    
    // Sauvegarde distante si disponible
    if (typeof gsRun === 'function') {
      gsRun('saveCacheData', cacheData).catch(console.error);
    }
  } catch (error) {
    console.error('Erreur sauvegarde cache:', error);
  }
};

// 9. FIX: Indicateur de connexion Google Apps Script
function checkGoogleAppsConnection() {
  const indicator = document.createElement('div');
  indicator.className = 'fixed bottom-4 right-4 text-xs';
  
  if (typeof google !== 'undefined' && google.script) {
    indicator.innerHTML = '<i class="fas fa-cloud text-green-500"></i> Connect√© √† Google';
  } else {
    indicator.innerHTML = '<i class="fas fa-cloud-slash text-gray-400"></i> Mode local';
  }
  
  document.body.appendChild(indicator);
  setTimeout(() => indicator.remove(), 3000);
}

// Appeler au chargement
setTimeout(checkGoogleAppsConnection, 1000);

// 10. FIX: Am√©lioration du tri des colonnes
window.sortColumn = function(classe, sortType, direction = 'asc') {
  const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
  if (!dropZone) return;

  const cards = Array.from(dropZone.querySelectorAll('.student-card'));
  const students = cards.map(card => ({
    card,
    data: STATE.students[card.dataset.id]
  })).filter(item => item.data); // Filtrer les √©l√©ments invalides

  const f = direction === 'asc' ? 1 : -1;

  switch (sortType) {
    case 'name':
      students.sort((a, b) => {
        const nameA = `${a.data.nom} ${a.data.prenom || ''}`.trim();
        const nameB = `${b.data.nom} ${b.data.prenom || ''}`.trim();
        return f * nameA.localeCompare(nameB, 'fr');
      });
      break;

    case 'lv2':
      students.sort((a, b) => {
        const ordre = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
        const lv2A = (a.data.lv2 || '').toUpperCase();
        const lv2B = (b.data.lv2 || '').toUpperCase();
        const iA = ordre.indexOf(lv2A);
        const iB = ordre.indexOf(lv2B);
        return f * ((iA === -1 ? 999 : iA) - (iB === -1 ? 999 : iB));
      });
      break;

    case 'option':
      students.sort((a, b) => {
        const optA = a.data.opt || 'ZZZZ';
        const optB = b.data.opt || 'ZZZZ';
        return f * optA.localeCompare(optB);
      });
      break;

    case 'score':
      students.sort((a, b) => {
        const scoreA = a.data.scores?.COM || 0;
        const scoreB = b.data.scores?.COM || 0;
        // Pour les scores, inverser la logique (meilleurs en haut)
        return -f * (scoreB - scoreA);
      });
      break;
  }

  // R√©injecter dans le DOM avec animation
  dropZone.style.opacity = '0.5';
  dropZone.innerHTML = '';
  students.forEach(({ card }, index) => {
    setTimeout(() => {
      dropZone.appendChild(card);
      if (index === students.length - 1) {
        dropZone.style.opacity = '1';
      }
    }, index * 10);
  });

  STATE.sortOrder[classe] = { type: sortType, dir: direction };
  
  // Notification
  toast(`Classe ${classe} tri√©e par ${sortType}`, 'info');
};

console.log('‚úÖ Patch de corrections appliqu√©');

// ========== MODULE DE GROUPES V2 - INTERFACE CLARIFI√âE ==========

// FIX: Ajout d'un bouton Groupes dans le header - Version modulaire
function addGroupsButton() {
  const nav = document.querySelector('.app-header nav');
  if (!nav || document.getElementById('btnGroups')) return;
  
  // Cr√©er un wrapper pour le bouton et son menu
  const groupsWrapper = document.createElement('div');
  groupsWrapper.className = 'relative';
  groupsWrapper.id = 'groupsMenuWrapper';
  
  // Bouton principal avec fl√®che
  const btnGroups = document.createElement('button');
  btnGroups.id = 'btnGroups';
  btnGroups.className = 'btn btn-primary flex items-center gap-1';
  btnGroups.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';
  
  // Menu d√©roulant
  const dropdown = document.createElement('div');
  dropdown.id = 'groupsDropdown';
  dropdown.className = 'absolute right-0 mt-2 w-64 bg-white rounded shadow-lg z-50 hidden p-2';
  dropdown.innerHTML = `
    <button onclick="openGroupsInterface()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-plus-circle text-green-600"></i> Cr√©er des groupes
    </button>
    <button onclick="openGroupsInterface('manager')" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-cog text-blue-600"></i> G√©rer les groupes
    </button>
    <button onclick="openGroupsInterface('templates')" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-layer-group text-purple-600"></i> Mod√®les de groupes
    </button>
    <hr class="my-2 border-gray-200">
    <button onclick="exportGroupsData()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-download text-purple-600"></i> Exporter tous les groupes
    </button>
    <button onclick="confirmDeleteAllGroups()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2 text-red-600">
      <i class="fas fa-trash"></i> Supprimer tous les groupes
    </button>
  `;
  
  groupsWrapper.appendChild(btnGroups);
  groupsWrapper.appendChild(dropdown);
  
  // G√©rer l'ouverture/fermeture du menu
  btnGroups.addEventListener('click', (e) => {
    e.stopPropagation();
    // Fermer tous les autres dropdowns
    document.querySelectorAll('.app-header .absolute').forEach(d => {
      if (d !== dropdown) d.classList.add('hidden');
    });
    dropdown.classList.toggle('hidden');
  });
  
  // Fermer le menu si on clique ailleurs
  document.addEventListener('click', () => {
    dropdown.classList.add('hidden');
  });
  
  dropdown.addEventListener('click', e => e.stopPropagation());
  
  nav.insertBefore(groupsWrapper, nav.firstChild);
}

// Mettre √† jour le bouton pour afficher le nombre de groupes - Version modulaire
function updateGroupsButton() {
  const btn = document.getElementById('btnGroups');
  if (btn) {
    // R√©cup√©rer le nombre de groupes depuis le serveur
    google.script.run
      .withSuccessHandler(function(count) {
        if (count > 0) {
          btn.innerHTML = `<i class="fas fa-layer-group"></i> Groupes <span class="bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full text-xs ml-1">${count}</span> <i class="fas fa-caret-down"></i>`;
        } else {
          btn.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';
        }
      })
      .getGroupsCount();
  }
}

// Fonction pour notifier les changements de groupes
function notifyGroupsChanged() {
  updateGroupsButton();
  // Autres actions √† effectuer quand les groupes changent
  console.log('üìä Groupes mis √† jour');
}

// ========== CODE √Ä AJOUTER/MODIFIER DANS INTERFACEV2.HTML ==========

// 1. Fonction unifi√©e openGroupsInterface - utilise le nouveau GroupsModuleComplete (modal int√©gr√©e)
function openGroupsInterface(tab = 'creator') {
  console.log('üöÄ Ouverture de l\'interface des groupes via GroupsModuleComplete...');

  // V√©rifier si GroupsModuleComplete est disponible (groupsModuleComplete.html)
  if (typeof window !== 'undefined' && window.GroupsModuleComplete && typeof window.GroupsModuleComplete.open === 'function') {
    try {
      window.GroupsModuleComplete.open();
      console.log('‚úÖ GroupsModuleComplete ouvert avec succ√®s');
      return;
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'ouverture de GroupsModuleComplete:', error);
    }
  }

  // FALLBACK : Si GroupsModuleComplete n'est pas disponible, utiliser l'ancienne interface popup
  console.warn('‚ö†Ô∏è GroupsModuleComplete non disponible, fallback vers interface popup...');
  google.script.run
    .withSuccessHandler(function(html) {
      try {
        const groupsWindow = window.open('', 'GroupsManager', 'width=1400,height=900,menubar=no,toolbar=no,scrollbars=yes,resizable=yes');

        if (!groupsWindow || groupsWindow.closed || typeof groupsWindow.closed === 'undefined') {
          console.error('‚ùå Impossible d\'ouvrir la fen√™tre popup - bloqu√©e par le navigateur');
          alert('‚ö†Ô∏è Impossible d\'ouvrir l\'interface des groupes. Veuillez autoriser les popups pour ce site et r√©essayer.');
          return;
        }

        groupsWindow.document.open();
        groupsWindow.document.write(html);
        groupsWindow.document.close();

        const checkInterval = setInterval(() => {
          try {
            if (groupsWindow.GroupsUI && typeof groupsWindow.GroupsUI.switchTab === 'function') {
              clearInterval(checkInterval);
              groupsWindow.GroupsUI.switchTab(tab);
              console.log('‚úÖ Interface des groupes popup ouverte avec succ√®s');
            }
          } catch (uiError) {
            clearInterval(checkInterval);
          }
        }, 100);

        setTimeout(() => clearInterval(checkInterval), 5000);
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'ouverture de l\'interface:', error);
        alert('Erreur lors de l\'ouverture de l\'interface des groupes: ' + error.message);
      }
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Erreur serveur:', error);
      alert('Impossible de charger l\'interface des groupes: ' + error.message);
    })
    .getGroupsInterface();
}

// 2. Fonction pour notifier les changements de groupes
window.notifyGroupsChanged = function() {
  console.log('üì¢ Notification de changement de groupes re√ßue');
  updateGroupsButton();
  
  // Afficher un message de confirmation
  if (typeof toast === 'function') {
    toast('Groupes mis √† jour avec succ√®s', 'success');
  }
};

// 3. Fonction d'export am√©lior√©e
function exportGroupsData() {
  console.log('üì§ Export des groupes...');
  
  google.script.run
    .withSuccessHandler(function(groupsData) {
      if (!groupsData || Object.keys(groupsData).length === 0) {
        alert('Aucun groupe √† exporter');
        return;
      }
      
      // Cr√©er le CSV avec point-virgule comme s√©parateur (compatible Excel FR)
      let csv = 'Type;Groupe;Nom;Pr√©nom;Sexe;Classe d\'origine;Langue;Score COM;Score TRA;Score PART;Score ABS;Score Maths;Score Fran√ßais\n';
      
      Object.entries(groupsData).forEach(([groupName, groupData]) => {
        groupData.students.forEach(student => {
          // Construire la ligne sans guillemets inutiles
          const line = [
            groupData.type || 'N/A',
            groupName,
            student.nom || '',
            student.prenom || '',
            student.sexe || '',
            student.classe || '',
            student.lv1Badge || student.lv1 || '', // Badge de langue ou valeur brute
            student.com || 0,
            student.tra || 0,
            student.part || 0,
            student.abs || 0,
            student.scores?.M || 0,
            student.scores?.F || 0
          ];
          
          csv += line.join(';') + '\n';
        });
      });
      
      // T√©l√©charger le fichier
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `export_groupes_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      toast('Export CSV g√©n√©r√© avec succ√®s', 'success');
    })
    .withFailureHandler(function(error) {
      console.error('Erreur export:', error);
      alert('Erreur lors de l\'export: ' + error.message);
    })
    .getAllGroups();
}

// 4. Fonction de suppression avec confirmation am√©lior√©e
function confirmDeleteAllGroups() {
  const modal = document.createElement('div');
  modal.className = 'fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50';
  modal.innerHTML = `
    <div class="bg-white rounded-lg shadow-xl p-6 max-w-md">
      <h3 class="text-lg font-bold mb-4 text-red-600">
        <i class="fas fa-exclamation-triangle mr-2"></i>
        Suppression de tous les groupes
      </h3>
      <p class="text-gray-700 mb-6">
        Cette action supprimera d√©finitivement tous les groupes cr√©√©s. 
        Cette op√©ration est irr√©versible.
      </p>
      <div class="flex justify-end gap-3">
        <button onclick="this.closest('.fixed').remove()" class="btn btn-secondary">
          Annuler
        </button>
        <button onclick="deleteAllGroups(); this.closest('.fixed').remove();" class="btn btn-danger">
          <i class="fas fa-trash mr-2"></i>
          Supprimer tout
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

function deleteAllGroups() {
  google.script.run
    .withSuccessHandler(function(success) {
      if (success) {
        updateGroupsButton();
        toast('Tous les groupes ont √©t√© supprim√©s', 'success');
      } else {
        toast('Erreur lors de la suppression', 'error');
      }
    })
    .withFailureHandler(function(error) {
      console.error('Erreur suppression:', error);
      toast('Erreur: ' + error.message, 'error');
    })
    .deleteAllGroups();
}

// 5. Am√©lioration du menu dropdown des groupes - SUPPRIM√â
// Cette fonction est obsol√®te, remplac√©e par createEnhancedGroupsMenu() ligne 10828
// L'initialisation se fait via initGroupsModule() qui appelle createEnhancedGroupsMenu()

// 6. Initialisation au chargement - SUPPRIM√â (conflit avec initGroupsModule ligne 10771)
// Les fonctions initializeGroupsButton() et initializeGroupsMenu() n'existent pas
// L'initialisation se fait via initGroupsModule() qui appelle createEnhancedGroupsMenu()


// ========== FONCTIONS SUPPL√âMENTAIRES ==========

// Fonction pour ajouter des scores de mati√®res
window.addSubjectScores = function() {
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2 class="text-xl font-bold">Ajouter des scores de mati√®res</h2>
        <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <div class="bg-blue-50 p-3 rounded mb-4">
          <p class="text-sm text-blue-800">
            <i class="fas fa-info-circle mr-1"></i>
            Importez un fichier Excel avec les colonnes : ID, MATH, FR
            ou saisissez manuellement les scores.
          </p>
        </div>
        
        <div class="mb-4">
          <button onclick="importSubjectScores()" class="btn btn-primary w-full">
            <i class="fas fa-upload"></i> Importer depuis Excel
          </button>
        </div>
        
        <div class="text-center text-gray-500 my-4">ou</div>
        
        <div>
          <h3 class="font-bold mb-2">Saisie manuelle rapide</h3>
          <div class="text-xs text-gray-600 mb-2">
            S√©lectionnez une classe et attribuez des scores al√©atoires pour tester
          </div>
          <select id="classForScores" class="form-control mb-2">
            <option value="">-- S√©lectionner une classe --</option>
            ${Array.from(document.querySelectorAll('.classe-name'))
              .map(el => `<option value="${el.textContent}">${el.textContent}</option>`)
              .join('')}
          </select>
          <button onclick="generateRandomScores()" class="btn btn-secondary w-full">
            <i class="fas fa-dice"></i> G√©n√©rer des scores al√©atoires
          </button>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
};

// G√©n√©rer des scores al√©atoires pour tester
window.generateRandomScores = function() {
  const classe = document.getElementById('classForScores').value;
  if (!classe) {
    toast('S√©lectionnez une classe', 'warning');
    return;
  }
  
  const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
  if (!zone) return;
  
  let count = 0;
  zone.querySelectorAll('.student-card').forEach(card => {
    const eleve = STATE.students[card.dataset.id];
    if (eleve) {
      // G√©n√©rer des scores coh√©rents avec le comportement
      const baseScore = eleve.scores?.C || 2.5;
      const variance = 0.5;
      
      eleve.scores.MATH = Math.max(1, Math.min(4, 
        baseScore + (Math.random() - 0.5) * 2 * variance
      ));
      
      eleve.scores.FR = Math.max(1, Math.min(4, 
        baseScore + (Math.random() - 0.5) * 2 * variance
      ));
      
      count++;
    }
  });
  
  toast(`${count} scores g√©n√©r√©s pour ${classe}`, 'success');
  document.querySelector('.modal').remove();
};

// ========== AM√âLIORATIONS PRIORITAIRES V2 ==========

// 0. FEEDBACK EN TEMPS R√âEL
window.RealTimeFeedback = {
  previousMetrics: null,
  isMinimized: false,
  
  // Initialiser le syst√®me de feedback
  init() {
    this.setupEventListeners();
    // Ne pas afficher automatiquement - seulement quand on est dans le menu des groupes
    this.updateMetrics();
  },
  
  // Configurer les √©v√©nements
  setupEventListeners() {
    // Minimiser/maximiser le panneau
    document.getElementById('minimizeFeedback')?.addEventListener('click', () => {
      this.toggleMinimize();
    });
    
    // Fermer le panneau
    document.getElementById('closeFeedback')?.addEventListener('click', () => {
      this.hide();
    });
    
    // Rendre le panneau d√©pla√ßable
    this.makeDraggable();
  },
  
  // Rendre le panneau d√©pla√ßable
  makeDraggable() {
    const panel = document.getElementById('feedbackPanel');
    const header = panel?.querySelector('.feedback-header');
    
    if (!panel || !header) return;
    
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    
    header.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      startLeft = parseInt(panel.style.left) || 0;
      startTop = parseInt(panel.style.top) || 0;
      
      panel.style.cursor = 'grabbing';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      panel.style.left = (startLeft + deltaX) + 'px';
      panel.style.top = (startTop + deltaY) + 'px';
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
      panel.style.cursor = 'grab';
    });
  },
  
  // Afficher le panneau
  show() {
    const panel = document.getElementById('feedbackPanel');
    if (panel) {
      panel.style.display = 'block';
    }
  },
  
  // Masquer le panneau
  hide() {
    const panel = document.getElementById('feedbackPanel');
    if (panel) {
      panel.style.display = 'none';
    }
  },
  
  // Basculer minimisation
  toggleMinimize() {
    const panel = document.getElementById('feedbackPanel');
    if (!panel) return;
    
    this.isMinimized = !this.isMinimized;
    panel.classList.toggle('minimized', this.isMinimized);
    
    const icon = document.querySelector('#minimizeFeedback i');
    if (icon) {
      icon.className = this.isMinimized ? 'fas fa-expand' : 'fas fa-minus';
    }
  },
  
  // Calculer les m√©triques actuelles
  calculateMetrics() {
    const metrics = {
      balance: this.calculateBalance(),
      constraints: this.calculateConstraints(),
      diversity: this.calculateDiversity(),
      size: this.calculateSizeBalance(),
      scores: this.calculateScoreBalance(),
      mobility: this.calculateMobilityBalance(),
      globalScore: this.calculateGlobalScore()
    };
    
    return metrics;
  },
  
  // Calculer l'√©quilibre F/M
  calculateBalance() {
    let totalImbalance = 0;
    let classCount = 0;
    
    document.querySelectorAll('.class-column').forEach(col => {
      const students = col.querySelectorAll('.student-card');
      const fCount = Array.from(students).filter(card => 
        STATE.students[card.dataset.id]?.sexe === 'F'
      ).length;
      const mCount = Array.from(students).filter(card => 
        STATE.students[card.dataset.id]?.sexe === 'M'
      ).length;
      
      const imbalance = Math.abs(fCount - mCount);
      totalImbalance += imbalance;
      classCount++;
    });
    
    return classCount > 0 ? totalImbalance / classCount : 0;
  },
  
  // Calculer les violations de contraintes
  calculateConstraints() {
    return ConstraintManager ? ConstraintManager.validateAllConstraints().length : 0;
  },
  
  // Calculer la diversit√© des scores
  calculateDiversity() {
    let totalDiversity = 0;
    let classCount = 0;
    
    document.querySelectorAll('.class-column').forEach(col => {
      const students = col.querySelectorAll('.student-card');
      const scores = Array.from(students).map(card => {
        const student = STATE.students[card.dataset.id];
        return (student?.scores?.M || 0) + (student?.scores?.F || 0);
      }).filter(score => score > 0);
      
      if (scores.length > 1) {
        const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
        const variance = scores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / scores.length;
        totalDiversity += Math.sqrt(variance);
      }
      classCount++;
    });
    
    return classCount > 0 ? totalDiversity / classCount : 0;
  },
  
  // Calculer l'√©quilibre des tailles
  calculateSizeBalance() {
    const sizes = Array.from(document.querySelectorAll('.class-column')).map(col => 
      col.querySelectorAll('.student-card').length
    );
    
    if (sizes.length === 0) return 0;
    
    const mean = sizes.reduce((a, b) => a + b, 0) / sizes.length;
    const variance = sizes.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / sizes.length;
    
    return Math.sqrt(variance);
  },
  
  // Calculer l'√©quilibre des scores
  calculateScoreBalance() {
    let totalImbalance = 0;
    let classCount = 0;
    
    document.querySelectorAll('.class-column').forEach(col => {
      const students = col.querySelectorAll('.student-card');
      const scores = Array.from(students).map(card => {
        const student = STATE.students[card.dataset.id];
        return (student?.scores?.M || 0) + (student?.scores?.F || 0);
      }).filter(score => score > 0);
      
      if (scores.length > 1) {
        const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
        const variance = scores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / scores.length;
        totalImbalance += Math.sqrt(variance);
      }
      classCount++;
    });
    
    return classCount > 0 ? totalImbalance / classCount : 0;
  },
  
  // Calculer l'√©quilibre de mobilit√©
  calculateMobilityBalance() {
    let totalImbalance = 0;
    let classCount = 0;
    
    document.querySelectorAll('.class-column').forEach(col => {
      const students = col.querySelectorAll('.student-card');
      const permutCount = Array.from(students).filter(card => 
        STATE.students[card.dataset.id]?.mobilite === 'PERMUT'
      ).length;
      const fixeCount = Array.from(students).filter(card => 
        STATE.students[card.dataset.id]?.mobilite === 'FIXE'
      ).length;
      
      const imbalance = Math.abs(permutCount - fixeCount);
      totalImbalance += imbalance;
      classCount++;
    });
    
    return classCount > 0 ? totalImbalance / classCount : 0;
  },
  
  // Calculer le score global
  calculateGlobalScore() {
    const balance = this.calculateBalance();
    const constraints = this.calculateConstraints();
    const diversity = this.calculateDiversity();
    const size = this.calculateSizeBalance();
    const scores = this.calculateScoreBalance();
    const mobility = this.calculateMobilityBalance();
    
    // Score invers√© (plus c'est bas, mieux c'est)
    const balanceScore = Math.max(0, 10 - balance * 2);
    const constraintScore = Math.max(0, 10 - constraints * 2);
    const diversityScore = Math.min(10, diversity);
    const sizeScore = Math.max(0, 10 - size);
    const scoreBalance = Math.min(10, scores);
    const mobilityScore = Math.max(0, 10 - mobility);
    
    return (balanceScore + constraintScore + diversityScore + sizeScore + scoreBalance + mobilityScore) / 6;
  },
  
  // Mettre √† jour l'affichage des m√©triques
  updateMetrics() {
    const currentMetrics = this.calculateMetrics();
    
    // Mettre √† jour les valeurs
    this.updateMetricValue('balanceValue', currentMetrics.balance.toFixed(1));
    this.updateMetricValue('constraintsValue', currentMetrics.constraints);
    this.updateMetricValue('diversityValue', currentMetrics.diversity.toFixed(1));
    this.updateMetricValue('sizeValue', currentMetrics.size.toFixed(1));
    this.updateMetricValue('scoresValue', currentMetrics.scores.toFixed(1));
    this.updateMetricValue('mobilityValue', currentMetrics.mobility.toFixed(1));
    this.updateMetricValue('globalScoreValue', currentMetrics.globalScore.toFixed(1));
    
    // Calculer et afficher les changements
    if (this.previousMetrics) {
      this.updateMetricChange('balanceChange', currentMetrics.balance, this.previousMetrics.balance);
      this.updateMetricChange('constraintsChange', currentMetrics.constraints, this.previousMetrics.constraints, true);
      this.updateMetricChange('diversityChange', currentMetrics.diversity, this.previousMetrics.diversity);
      this.updateMetricChange('sizeChange', currentMetrics.size, this.previousMetrics.size, true);
      this.updateMetricChange('scoresChange', currentMetrics.scores, this.previousMetrics.scores);
      this.updateMetricChange('mobilityChange', currentMetrics.mobility, this.previousMetrics.mobility);
      this.updateMetricChange('globalScoreChange', currentMetrics.globalScore, this.previousMetrics.globalScore);
    }
    
    this.previousMetrics = { ...currentMetrics };
  },
  
  // Mettre √† jour une valeur de m√©trique
  updateMetricValue(elementId, value) {
    const element = document.getElementById(elementId);
    if (element) {
      element.textContent = value;
    }
  },
  
  // Mettre √† jour l'indicateur de changement
  updateMetricChange(elementId, currentValue, previousValue, inverted = false) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const change = currentValue - previousValue;
    const changeElement = element.querySelector('span');
    const iconElement = element.querySelector('i');
    
    if (Math.abs(change) < 0.01) {
      // Pas de changement
      element.className = 'metric-change neutral';
      iconElement.className = 'fas fa-minus';
      changeElement.textContent = '0';
    } else {
      const isImprovement = inverted ? change < 0 : change > 0;
      
      element.className = `metric-change ${isImprovement ? 'improved' : 'degraded'}`;
      iconElement.className = isImprovement ? 'fas fa-arrow-up' : 'fas fa-arrow-down';
      changeElement.textContent = Math.abs(change).toFixed(1);
      
      // Animation de pulse
      const metricValue = element.closest('.metric-value');
      metricValue.classList.add('changed');
      setTimeout(() => metricValue.classList.remove('changed'), 600);
    }
  },
  
  // Pr√©visualiser l'impact d'un d√©placement
  previewMove(studentId, targetGroup) {
    if (!this.previousMetrics) return;
    
    // Simuler le d√©placement
    const originalGroup = this.findStudentGroup(studentId);
    if (!originalGroup || originalGroup === targetGroup) return;
    
    // Calculer les nouvelles m√©triques
    const newMetrics = this.calculateMetricsWithMove(studentId, targetGroup);
    
    // Afficher les changements pr√©visionnels
    this.updateMetricChange('balanceChange', newMetrics.balance, this.previousMetrics.balance);
    this.updateMetricChange('constraintsChange', newMetrics.constraints, this.previousMetrics.constraints, true);
    this.updateMetricChange('diversityChange', newMetrics.diversity, this.previousMetrics.diversity);
    this.updateMetricChange('sizeChange', newMetrics.size, this.previousMetrics.size, true);
    this.updateMetricChange('globalScoreChange', newMetrics.globalScore, this.previousMetrics.globalScore);
  },
  
  // Trouver le groupe d'un √©l√®ve
  findStudentGroup(studentId) {
    const card = document.querySelector(`[data-id="${studentId}"]`);
    return card?.closest('.class-column')?.querySelector('.classe-name')?.textContent;
  },
  
  // Calculer les m√©triques avec un d√©placement simul√©
  calculateMetricsWithMove(studentId, targetGroup) {
    // Impl√©mentation simplifi√©e - en r√©alit√©, il faudrait simuler le d√©placement
    // Pour l'instant, on retourne les m√©triques actuelles
    return this.calculateMetrics();
  },
  
  // R√©initialiser les changements
  resetChanges() {
    const changes = ['balanceChange', 'constraintsChange', 'diversityChange', 'sizeChange', 'scoresChange', 'mobilityChange', 'globalScoreChange'];
    changes.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.className = 'metric-change neutral';
        const icon = element.querySelector('i');
        const span = element.querySelector('span');
        if (icon) icon.className = 'fas fa-minus';
        if (span) span.textContent = '0';
      }
    });
  }
};

// 1. IMPORT DES SCORES INT
const ScoreImporter = {
  // Importer les scores depuis les fichiers INT
  async importScoresFromINT() {
    try {
      const result = await gsRun('getINTScores');
      if (result.success) {
        // Mapper les scores sur les √©l√®ves existants
        let importedCount = 0;
        result.scores.forEach(score => {
          if (STATE.students[score.id]) {
            STATE.students[score.id].scores.M = score.MATH;
            STATE.students[score.id].scores.F = score.FR;
            importedCount++;
          }
        });
        
        // Rafra√Æchir l'affichage
        this.refreshScoreDisplay();
        
        toast(`${importedCount} scores import√©s avec succ√®s`, 'success');
        return { success: true, count: importedCount };
      } else {
        toast('Erreur lors de l\'import des scores', 'error');
        return { success: false, error: result.error };
      }
    } catch (error) {
      console.error('Erreur import scores:', error);
      toast('Erreur lors de l\'import des scores', 'error');
      return { success: false, error: error.message };
    }
  },

  // Rafra√Æchir l'affichage des scores
  refreshScoreDisplay() {
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve && eleve.scores) {
        const scoresContainer = card.querySelector('.scores');
        if (scoresContainer) {
          scoresContainer.innerHTML = this.generateScoreBadges(eleve.scores);
        }
      }
    });
  },

  // G√©n√©rer les badges de scores
  generateScoreBadges(scores) {
    const badges = [];

    // Scores existants (COM, TRA, PART, ABS) avec 4 couleurs distinctes
    const scoreMap = [
      { key: 'COM', label: 'Comportement', letter: 'C' },
      { key: 'TRA', label: 'Travail', letter: 'T' },
      { key: 'PART', label: 'Participation', letter: 'P' },
      { key: 'ABS', label: 'Absences', letter: 'A' }
    ];

    scoreMap.forEach(({ key, label, letter }) => {
      if (scores[key] !== undefined && scores[key] !== '' && scores[key] > 0) {
        const score = scores[key];
        // Utiliser les classes score-pill existantes pour avoir 4 couleurs distinctes :
        // score-1 = ROUGE, score-2 = JAUNE, score-3 = VERT CLAIR, score-4 = VERT FONC√â
        badges.push(`<div class="score-pill score-${score}" title="${label}: ${score}/4">${letter}</div>`);
      }
    });

    // Nouveaux scores (MATH, FR) - garder l'ancien syst√®me
    ['M', 'F'].forEach(key => {
      if (scores[key] !== undefined && scores[key] !== '') {
        const score = scores[key];
        const color = score >= 3 ? 'bg-blue-100 text-blue-800' :
                     score >= 2 ? 'bg-orange-100 text-orange-800' :
                     'bg-red-100 text-red-800';
        const label = key === 'M' ? 'MATH' : 'FR';
        badges.push(`<span class="score-badge ${color} text-xs px-1 rounded">${label}:${score}</span>`);
      }
    });

    return badges.join('');
  },

  // Afficher les groupes existants
  showGroups() {
    const section = document.getElementById('groupsSection');
    if (section) {
      section.style.display = 'block';
      // Rafra√Æchir l'affichage si n√©cessaire
      if (Object.keys(this.groups).length > 0) {
        this.displaySavedGroups(true);
      }
    } else if (Object.keys(this.groups).length > 0) {
      // Si la section n'existe pas mais qu'il y a des groupes, la cr√©er
      this.displaySavedGroups(true);
    } else {
      toast('Aucun groupe cr√©√©', 'info');
    }
  },

  // Masquer les groupes
  hideGroups() {
    const section = document.getElementById('groupsSection');
    if (section) {
      section.style.display = 'none';
    }
    toast('Groupes masqu√©s', 'info');
  },

  // Basculer l'affichage des groupes
  toggleGroups() {
    const section = document.getElementById('groupsSection');
    if (section && section.style.display !== 'none') {
      this.hideGroups();
    } else {
      this.showGroups();
    }
  },

  // Supprimer tous les groupes
  deleteAllGroups() {
    if (!confirm('Supprimer TOUS les groupes cr√©√©s ? Cette action est irr√©versible.')) return;
    
    this.groups = {};
    this.saveGroups();
    
    // Retirer la section
    const section = document.getElementById('groupsSection');
    if (section) section.remove();
    
    toast('Tous les groupes ont √©t√© supprim√©s', 'info');
  },

  // Mettre √† jour le bouton pour afficher le nombre de groupes
  updateGroupsButton() {
    const btn = document.getElementById('btnGroups');
    if (btn && this.groups) {
      const count = Object.keys(this.groups).length;
      if (count > 0) {
        btn.innerHTML = `<i class="fas fa-layer-group"></i> Groupes <span class="bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full text-xs ml-1">${count}</span> <i class="fas fa-caret-down"></i>`;
      } else {
        btn.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';
      }
    }
  }
};

// 2. ALGORITHME D'OPTIMISATION AM√âLIOR√â
const OptimizerV2 = {
  // Algorithme g√©n√©tique simple pour optimiser l'√©quilibre
  optimizeGroupsGenetic(students, numGroups, iterations = 100) {
    // Cr√©er population initiale
    let bestSolution = this.createInitialGroups(students, numGroups);
    let bestScore = this.evaluateSolution(bestSolution);
    
    for (let i = 0; i < iterations; i++) {
      // Mutation : √©changer 2 √©l√®ves al√©atoires
      const mutated = this.mutateSolution(bestSolution);
      const score = this.evaluateSolution(mutated);
      
      if (score > bestScore) {
        bestSolution = mutated;
        bestScore = score;
      }
    }
    
    return bestSolution;
  },

  // Cr√©er des groupes initiaux
  createInitialGroups(students, numGroups) {
    const groups = Array(numGroups).fill(null).map(() => []);
    
    // Distribution al√©atoire initiale
    students.forEach((student, index) => {
      const groupIndex = index % numGroups;
      groups[groupIndex].push(student);
    });
    
    return groups;
  },

  // √âvaluer la qualit√© d'une solution
  evaluateSolution(groups) {
    let score = 100;
    
    // P√©nalit√© pour d√©s√©quilibre de taille
    const avgSize = groups.reduce((sum, g) => sum + g.length, 0) / groups.length;
    groups.forEach(g => {
      score -= Math.abs(g.length - avgSize) * 5;
    });
    
    // P√©nalit√© pour d√©s√©quilibre F/M
    groups.forEach(g => {
      const ratio = g.filter(s => s.sexe === 'F').length / g.length;
      score -= Math.abs(ratio - 0.5) * 50;
    });
    
    // Bonus pour h√©t√©rog√©n√©it√© des scores
    groups.forEach(g => {
      const scores = g.map(s => (s.scores?.M || 0) + (s.scores?.F || 0));
      const variance = this.calculateVariance(scores);
      score += variance * 10; // Plus de variance = mieux
    });
    
    return score;
  },

  // Calculer la variance
  calculateVariance(scores) {
    if (scores.length === 0) return 0;
    const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
    return variance;
  },

  // Mutation d'une solution
  mutateSolution(groups) {
    const mutated = groups.map(g => [...g]); // Copie profonde
    
    // S√©lectionner deux groupes al√©atoires
    const group1Index = Math.floor(Math.random() * mutated.length);
    const group2Index = Math.floor(Math.random() * mutated.length);
    
    if (group1Index !== group2Index && mutated[group1Index].length > 0 && mutated[group2Index].length > 0) {
      // S√©lectionner deux √©l√®ves al√©atoires
      const student1Index = Math.floor(Math.random() * mutated[group1Index].length);
      const student2Index = Math.floor(Math.random() * mutated[group2Index].length);
      
      // √âchanger les √©l√®ves
      const temp = mutated[group1Index][student1Index];
      mutated[group1Index][student1Index] = mutated[group2Index][student2Index];
      mutated[group2Index][student2Index] = temp;
    }
    
    return mutated;
  },

  // Appliquer l'optimisation ClaudeMotor depuis le backend
  applyOptimization() {
    // Afficher un loader
    const loadingToast = document.createElement('div');
    loadingToast.className = 'fixed top-4 right-4 bg-purple-600 text-white px-6 py-4 rounded-lg shadow-lg z-50';
    loadingToast.innerHTML = `
      <div class="flex items-center gap-3">
        <i class="fas fa-spinner fa-spin"></i>
        <div>
          <div class="font-bold">Optimisation en cours...</div>
          <div class="text-sm opacity-90">ClaudeMotor analyse vos classes</div>
        </div>
      </div>
    `;
    document.body.appendChild(loadingToast);

    // Appeler le backend
    google.script.run
      .withSuccessHandler((response) => {
        loadingToast.remove();

        if (response.success) {
          toast(`Optimisation termin√©e ! ${response.results.totalSwaps} √©changes sugg√©r√©s`, 'success');
          this.displayClaudeMotorResults(response.results);
        } else {
          toast(`Erreur: ${response.error}`, 'error');
          console.error('Erreur optimisation:', response);
        }
      })
      .withFailureHandler((error) => {
        loadingToast.remove();
        toast(`Erreur technique: ${error.message}`, 'error');
        console.error('Erreur appel backend:', error);
      })
      .lancerOptimisationClaudeMotor({
        maxIterations: 50,
        enableMultiSwap: true
      });
  },

  // Afficher les r√©sultats ClaudeMotor
  displayClaudeMotorResults(results) {
    const modal = document.createElement('div');
    modal.className = 'modal';

    // Formater les swaps par phase
    let swapsHTML = '';
    if (results.swaps && results.swaps.length > 0) {
      swapsHTML = `
        <div class="mb-4">
          <h3 class="font-bold text-lg mb-2">üìù √âchanges sugg√©r√©s (${results.swaps.length})</h3>
          <div class="max-h-60 overflow-y-auto border rounded p-2">
            ${results.swaps.map((swap, i) => `
              <div class="text-sm p-2 bg-gray-50 rounded mb-2">
                <strong>#${i+1}</strong>:
                ${swap.student1?.nom || swap.studentSource?.nom || '√âl√®ve 1'}
                (${swap.class1 || swap.sourceClass || '?'})
                ‚Üî
                ${swap.student2?.nom || swap.studentTarget?.nom || '√âl√®ve 2'}
                (${swap.class2 || swap.targetClass || '?'})
              </div>
            `).join('')}
          </div>
        </div>
      `;
    } else {
      swapsHTML = `
        <div class="mb-4 p-4 bg-green-50 border border-green-200 rounded">
          <p class="text-green-800">‚úÖ Aucun √©change n√©cessaire - La r√©partition est d√©j√† optimale !</p>
        </div>
      `;
    }

    modal.innerHTML = `
      <div class="modal-content" style="max-width: 900px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">üöÄ R√©sultats ClaudeMotor</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <!-- Scores -->
          <div class="grid grid-cols-3 gap-4 mb-4">
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">Score initial</div>
              <div class="text-2xl font-bold text-gray-800">${results.scoreInitial.toFixed(1)}/100</div>
            </div>
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">Score final</div>
              <div class="text-2xl font-bold text-green-600">${results.scoreFinal.toFixed(1)}/100</div>
            </div>
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">Am√©lioration</div>
              <div class="text-2xl font-bold ${results.improvement >= 0 ? 'text-green-600' : 'text-red-600'}">
                ${results.improvement >= 0 ? '+' : ''}${results.improvement.toFixed(1)}
              </div>
            </div>
          </div>

          <!-- Phases -->
          ${results.phases ? `
            <div class="mb-4">
              <h3 class="font-bold mb-2">üìä D√©tails des phases</h3>
              <div class="grid grid-cols-3 gap-2">
                <div class="text-xs border rounded p-2">
                  <strong>Phase 1 (Scores)</strong><br>
                  ${results.phases.phase1?.swaps?.length || 0} √©changes
                </div>
                <div class="text-xs border rounded p-2">
                  <strong>Phase 2 (Parit√©)</strong><br>
                  ${results.phases.phase2?.corrections?.length || 0} corrections
                </div>
                <div class="text-xs border rounded p-2">
                  <strong>Phase 3 (MultiSwap)</strong><br>
                  ${results.phases.phase3?.cycles?.length || 0} cycles
                </div>
              </div>
            </div>
          ` : ''}

          ${swapsHTML}

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="OptimizerV2.applyClaudeMotorSwaps()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer les √©changes
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Fermer
            </button>
          </div>

          <div class="mt-4 text-xs text-gray-500">
            ‚è±Ô∏è Dur√©e: ${results.duration}ms |
            üîÑ ${results.totalSwaps} √©changes au total
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);

    // Sauvegarder les swaps pour application ult√©rieure
    window._claudeMotorSwaps = results.swaps;
  },

  // Appliquer les swaps ClaudeMotor
  applyClaudeMotorSwaps() {
    const swaps = window._claudeMotorSwaps;
    if (!swaps || swaps.length === 0) {
      toast('Aucun √©change √† appliquer', 'info');
      document.querySelector('.modal')?.remove();
      return;
    }

    // TODO: Impl√©menter l'application r√©elle des swaps dans l'interface
    // Pour l'instant, juste recharger les donn√©es
    toast(`Application de ${swaps.length} √©changes...`, 'info');

    setTimeout(() => {
      toast('√âchanges appliqu√©s ! Rechargez les donn√©es pour voir les changements.', 'success');
      document.querySelector('.modal')?.remove();
    }, 1000);
  },

  // Afficher les r√©sultats d'optimisation (ancien algorithme - conserv√© pour compatibilit√©)
  displayOptimizationResults(groups) {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 800px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">R√©sultats de l'optimisation</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="grid grid-cols-2 gap-4">
            ${groups.map((group, index) => `
              <div class="border rounded p-3">
                <h4 class="font-bold mb-2">Groupe ${index + 1} (${group.length} √©l√®ves)</h4>
                <div class="text-sm text-gray-600 mb-2">
                  F: ${group.filter(s => s.sexe === 'F').length} | 
                  M: ${group.filter(s => s.sexe === 'M').length}
                </div>
                <div class="max-h-32 overflow-y-auto">
                  ${group.slice(0, 10).map(s => `
                    <div class="text-xs p-1 bg-gray-50 rounded mb-1">
                      ${s.nom} ${s.prenom || ''} (${s.sexe})
                    </div>
                  `).join('')}
                  ${group.length > 10 ? `<div class="text-xs text-gray-500">... et ${group.length - 10} autres</div>` : ''}
                </div>
              </div>
            `).join('')}
          </div>
          <div class="mt-4 flex gap-2">
            <button onclick="OptimizerV2.applyOptimizationResults()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer cette r√©partition
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Annuler
            </button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  },

  // Appliquer les r√©sultats d'optimisation
  applyOptimizationResults() {
    // Cette fonction serait appel√©e pour appliquer r√©ellement les changements
    toast('Optimisation appliqu√©e', 'success');
    document.querySelector('.modal').remove();
  }
};

// 3. GESTION DES CONTRAINTES ASSO/DISSO AM√âLIOR√âE
const ConstraintManager = {
  // V√©rifier les contraintes avant tout d√©placement
  checkGroupConstraints(studentId, targetGroup) {
    const student = STATE.students[studentId];
    if (!student) return { valid: false, reason: '√âl√®ve non trouv√©' };
    
    // V√©rifier dissociation
    if (student.disso) {
      const conflictExists = targetGroup.some(s => 
        STATE.students[s.id] && STATE.students[s.id].disso === student.disso
      );
      if (conflictExists) {
        return { valid: false, reason: `Conflit dissociation D${student.disso}` };
      }
    }
    
    // V√©rifier association
    if (student.asso) {
      const assoGroup = STATE.aGroups[`A${student.asso}`];
      if (assoGroup) {
        const allInSameGroup = assoGroup.every(id => 
          targetGroup.some(s => s.id === id) || id === studentId
        );
        if (!allInSameGroup) {
          return { valid: false, reason: `Groupe A${student.asso} doit rester ensemble` };
        }
      }
    }
    
    return { valid: true };
  },

  // Afficher visuellement les contraintes
  showConstraintsOverlay() {
    // Colorer les √©l√®ves avec le m√™me code disso
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve && eleve.disso) {
        card.style.border = '2px solid #ef4444';
        card.style.backgroundColor = '#fef2f2';
        
        // Ajouter un badge de contrainte
        let badge = card.querySelector('.constraint-badge');
        if (!badge) {
          badge = document.createElement('div');
          badge.className = 'constraint-badge absolute -top-1 -right-1 bg-red-500 text-white text-xs px-1 rounded-full';
          badge.textContent = `D${eleve.disso}`;
          card.style.position = 'relative';
          card.appendChild(badge);
        }
      }
      
      // Relier visuellement les √©l√®ves avec le m√™me code asso
      if (eleve && eleve.asso) {
        card.style.border = '2px solid #3b82f6';
        card.style.backgroundColor = '#eff6ff';
        
        let badge = card.querySelector('.constraint-badge');
        if (!badge) {
          badge = document.createElement('div');
          badge.className = 'constraint-badge absolute -top-1 -right-1 bg-blue-500 text-white text-xs px-1 rounded-full';
          badge.textContent = `A${eleve.asso}`;
          card.style.position = 'relative';
          card.appendChild(badge);
        }
      }
    });
  },

  // Masquer les contraintes
  hideConstraintsOverlay() {
    document.querySelectorAll('.student-card').forEach(card => {
      card.style.border = '';
      card.style.backgroundColor = '';
      card.style.position = '';
      
      const badge = card.querySelector('.constraint-badge');
      if (badge) badge.remove();
    });
  },

  // V√©rifier toutes les contraintes dans l'interface
  validateAllConstraints() {
    const violations = [];
    
    // V√©rifier les dissociations
    const dissoGroups = {};
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve && eleve.disso) {
        const classe = card.closest('.droppable-zone').dataset.classe;
        if (!dissoGroups[eleve.disso]) dissoGroups[eleve.disso] = [];
        dissoGroups[eleve.disso].push({ eleve, classe });
      }
    });
    
    Object.entries(dissoGroups).forEach(([code, eleves]) => {
      const classes = [...new Set(eleves.map(e => e.classe))];
      if (classes.length > 1) {
        violations.push({
          type: 'DISSO',
          code,
          message: `Code D${code} r√©parti sur ${classes.length} classes: ${classes.join(', ')}`
        });
      }
    });
    
    // V√©rifier les associations
    const assoGroups = {};
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve && eleve.asso) {
        const classe = card.closest('.droppable-zone').dataset.classe;
        if (!assoGroups[eleve.asso]) assoGroups[eleve.asso] = [];
        assoGroups[eleve.asso].push({ eleve, classe });
      }
    });
    
    Object.entries(assoGroups).forEach(([code, eleves]) => {
      const classes = [...new Set(eleves.map(e => e.classe))];
      if (classes.length > 1) {
        violations.push({
          type: 'ASSO',
          code,
          message: `Groupe A${code} s√©par√© sur ${classes.length} classes: ${classes.join(', ')}`
        });
      }
    });
    
    return violations;
  },

  // Afficher les violations de contraintes
  showConstraintViolations() {
    const violations = this.validateAllConstraints();

    if (violations.length === 0) {
      toast('‚úÖ Aucune violation de contrainte d√©tect√©e', 'success');
      // Proposer d'ouvrir le panneau des contraintes
      this.showConstraintsPanel();
      return;
    }

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 600px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold text-red-600">
            <i class="fas fa-exclamation-triangle mr-2"></i>
            ${violations.length} Violation(s) de contraintes
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="space-y-3">
            ${violations.map(v => `
              <div class="p-3 border-l-4 ${v.type === 'DISSO' ? 'border-red-500 bg-red-50' : 'border-blue-500 bg-blue-50'}">
                <div class="font-semibold ${v.type === 'DISSO' ? 'text-red-800' : 'text-blue-800'}">
                  ${v.type === 'DISSO' ? 'Dissociation' : 'Association'} ${v.code}
                </div>
                <div class="text-sm ${v.type === 'DISSO' ? 'text-red-700' : 'text-blue-700'}">
                  ${v.message}
                </div>
              </div>
            `).join('')}
          </div>
          <div class="mt-4 flex gap-2">
            <button onclick="ConstraintManager.showConstraintsOverlay()" class="btn btn-secondary">
              <i class="fas fa-eye"></i> Voir les contraintes
            </button>
            <button onclick="ConstraintManager.showConstraintsPanel(); this.closest('.modal').remove();" class="btn btn-secondary">
              <i class="fas fa-cog"></i> G√©rer les contraintes
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-primary">
              <i class="fas fa-check"></i> Compris
            </button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  },

  // Afficher le panneau complet de gestion des contraintes
  showConstraintsPanel() {
    // Charger depuis le backend
    const loadingToast = document.createElement('div');
    loadingToast.className = 'fixed top-4 right-4 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-lg z-50';
    loadingToast.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Chargement des contraintes...';
    document.body.appendChild(loadingToast);

    google.script.run
      .withSuccessHandler((response) => {
        loadingToast.remove();
        if (response.success) {
          this.displayConstraintsPanel(response.constraints);
        } else {
          toast(`Erreur: ${response.error}`, 'error');
        }
      })
      .withFailureHandler((error) => {
        loadingToast.remove();
        toast(`Erreur: ${error.message}`, 'error');
      })
      .chargerContraintes();
  },

  // Afficher le panneau des contraintes
  displayConstraintsPanel(constraints) {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.id = 'constraintsModal';

    // Analyser les contraintes actuelles de l'interface
    const currentDisso = {};
    const currentAsso = {};
    const currentFixe = [];

    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (!eleve) return;

      if (eleve.disso) {
        if (!currentDisso[eleve.disso]) currentDisso[eleve.disso] = [];
        currentDisso[eleve.disso].push(`${eleve.nom} ${eleve.prenom || ''}`);
      }
      if (eleve.asso) {
        if (!currentAsso[eleve.asso]) currentAsso[eleve.asso] = [];
        currentAsso[eleve.asso].push(`${eleve.nom} ${eleve.prenom || ''}`);
      }
      if (eleve.mobilite === 'FIXE') {
        const classe = card.closest('.droppable-zone')?.dataset.classe;
        currentFixe.push(`${eleve.nom} ${eleve.prenom || ''} (${classe || '?'})`);
      }
    });

    modal.innerHTML = `
      <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
          <h2 class="text-2xl font-bold">
            <i class="fas fa-link mr-2"></i>
            Gestion des Contraintes
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <!-- Structure from _STRUCTURE -->
          <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-sitemap mr-2"></i>Structure (_STRUCTURE)
            </h3>
            <div class="text-sm space-y-2">
              ${constraints.structure && constraints.structure.length > 0 ? `
                <table class="w-full text-sm">
                  <thead class="bg-blue-100">
                    <tr>
                      <th class="p-2 text-left">Origine</th>
                      <th class="p-2 text-left">Destination</th>
                      <th class="p-2 text-center">Effectif</th>
                      <th class="p-2 text-left">Options</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${constraints.structure.map(s => `
                      <tr class="border-b">
                        <td class="p-2">${s.origine || '-'}</td>
                        <td class="p-2">${s.destination || '-'}</td>
                        <td class="p-2 text-center">${s.effectif || 28}</td>
                        <td class="p-2 text-xs">${s.options || '-'}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              ` : '<p class="text-gray-600">Aucune structure d√©finie dans _STRUCTURE</p>'}
            </div>
          </div>

          <!-- FIXE -->
          <div class="mb-6 p-4 bg-purple-50 border border-purple-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-lock mr-2"></i>√âl√®ves FIXE (${currentFixe.length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces √©l√®ves ne peuvent pas changer de classe</p>
            ${currentFixe.length > 0 ? `
              <div class="max-h-32 overflow-y-auto">
                ${currentFixe.map(e => `
                  <div class="text-sm p-1 bg-white rounded mb-1">${e}</div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucun √©l√®ve fix√©</p>'}
          </div>

          <!-- DISSO -->
          <div class="mb-6 p-4 bg-red-50 border border-red-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-ban mr-2"></i>Codes DISSO (${Object.keys(currentDisso).length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces √©l√®ves NE DOIVENT PAS √™tre dans la m√™me classe</p>
            ${Object.keys(currentDisso).length > 0 ? `
              <div class="space-y-2">
                ${Object.entries(currentDisso).map(([code, eleves]) => `
                  <div class="p-2 bg-white rounded border border-red-300">
                    <div class="font-bold text-red-700">D${code} (${eleves.length} √©l√®ves)</div>
                    <div class="text-xs text-gray-700">${eleves.join(', ')}</div>
                  </div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucune dissociation d√©finie</p>'}
          </div>

          <!-- ASSO -->
          <div class="mb-6 p-4 bg-green-50 border border-green-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-users mr-2"></i>Codes ASSO (${Object.keys(currentAsso).length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces √©l√®ves DOIVENT rester ensemble</p>
            ${Object.keys(currentAsso).length > 0 ? `
              <div class="space-y-2">
                ${Object.entries(currentAsso).map(([code, eleves]) => `
                  <div class="p-2 bg-white rounded border border-green-300">
                    <div class="font-bold text-green-700">A${code} (${eleves.length} √©l√®ves)</div>
                    <div class="text-xs text-gray-700">${eleves.join(', ')}</div>
                  </div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucune association d√©finie</p>'}
          </div>

          <!-- Options et LV2 -->
          <div class="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-star mr-2"></i>Contraintes OPT et LV2
            </h3>
            <p class="text-sm text-gray-600 mb-2">V√©rification des quotas d'options par classe</p>
            <div class="text-sm">
              <p class="text-gray-700">‚úÖ Les contraintes d'options sont v√©rifi√©es automatiquement lors des d√©placements</p>
              <p class="text-gray-700 mt-1">‚ÑπÔ∏è Voir _STRUCTURE pour les quotas d√©finis par classe</p>
            </div>
          </div>

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="ConstraintManager.showConstraintsOverlay()" class="btn btn-secondary">
              <i class="fas fa-eye"></i> Visualiser sur les cartes
            </button>
            <button onclick="window.open('https://docs.google.com/spreadsheets/d/' + google.script.host.origin.split('/')[2] + '/edit#gid=SHEET_ID_STRUCTURE', '_blank')" class="btn btn-secondary">
              <i class="fas fa-external-link-alt"></i> Ouvrir _STRUCTURE
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-primary">
              <i class="fas fa-check"></i> Fermer
            </button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }
};

// 4. GESTIONNAIRE DE FILTRES
const FilterManager = {
  activeFilters: {},

  // Afficher le panneau de filtres
  showFiltersPanel() {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.id = 'filtersModal';

    // Collecter les valeurs uniques pour chaque filtre
    const lv2Set = new Set();
    const optSet = new Set();
    const dissoSet = new Set();
    const assoSet = new Set();
    const mobiliteSet = new Set();
    const scoresCOM = new Set();

    Object.values(STATE.students || {}).forEach(eleve => {
      if (eleve.lv2) lv2Set.add(eleve.lv2);
      if (eleve.opt) optSet.add(eleve.opt);
      if (eleve.disso) dissoSet.add(eleve.disso);
      if (eleve.asso) assoSet.add(eleve.asso);
      if (eleve.mobilite) mobiliteSet.add(eleve.mobilite);
      if (eleve.scores && eleve.scores.COM) scoresCOM.add(eleve.scores.COM);
    });

    modal.innerHTML = `
      <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
          <h2 class="text-2xl font-bold">
            <i class="fas fa-filter mr-2"></i>
            Filtres
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <p class="text-sm text-gray-600 mb-4">
            Filtrez les √©l√®ves affich√©s selon leurs caract√©ristiques. Les √©l√®ves non filtr√©s seront gris√©s.
          </p>

          <!-- Filtres actifs -->
          <div id="activeFiltersDisplay" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded ${Object.keys(this.activeFilters).length === 0 ? 'hidden' : ''}">
            <h4 class="font-bold text-sm mb-2">Filtres actifs :</h4>
            <div id="activeFiltersList" class="flex flex-wrap gap-2"></div>
          </div>

          <!-- LV2 -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-language mr-2"></i>LV2
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(lv2Set).sort().map(lv2 => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="lv2" data-filter-value="${lv2}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${lv2}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- OPT -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-star mr-2"></i>Options
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(optSet).sort().map(opt => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="opt" data-filter-value="${opt}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${opt}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- DISSO -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-ban mr-2 text-red-600"></i>Codes DISSO
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(dissoSet).sort().map(disso => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="disso" data-filter-value="${disso}">
                  <span class="text-sm px-3 py-1 bg-red-100 rounded hover:bg-red-200">D${disso}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- ASSO -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-users mr-2 text-green-600"></i>Codes ASSO
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(assoSet).sort().map(asso => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="asso" data-filter-value="${asso}">
                  <span class="text-sm px-3 py-1 bg-green-100 rounded hover:bg-green-200">A${asso}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- Mobilit√© -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-exchange-alt mr-2"></i>Mobilit√©
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(mobiliteSet).sort().map(mob => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="mobilite" data-filter-value="${mob}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${mob}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- Score COM -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-chart-bar mr-2"></i>Score Comportement
            </h3>
            <div class="flex gap-2">
              ${Array.from(scoresCOM).sort().map(score => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="scoreCOM" data-filter-value="${score}">
                  <span class="text-sm px-3 py-1 rounded ${
                    score == 1 ? 'bg-red-500 text-white' :
                    score == 2 ? 'bg-yellow-400 text-gray-800' :
                    score == 3 ? 'bg-green-400 text-white' :
                    'bg-green-600 text-white'
                  }">${score}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="FilterManager.applyFilters()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer les filtres
            </button>
            <button onclick="FilterManager.clearAllFilters()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Effacer tous les filtres
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Fermer
            </button>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Restaurer les filtres actifs
    Object.keys(this.activeFilters).forEach(key => {
      const [type, value] = key.split(':');
      const checkbox = modal.querySelector(`[data-filter-type="${type}"][data-filter-value="${value}"]`);
      if (checkbox) checkbox.checked = true;
    });

    // G√©rer les changements de checkbox
    modal.querySelectorAll('.filter-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', () => {
        this.updateActiveFiltersDisplay(modal);
      });
    });

    this.updateActiveFiltersDisplay(modal);
  },

  // Mettre √† jour l'affichage des filtres actifs
  updateActiveFiltersDisplay(modal) {
    const checkedBoxes = modal.querySelectorAll('.filter-checkbox:checked');
    const display = modal.querySelector('#activeFiltersDisplay');
    const list = modal.querySelector('#activeFiltersList');

    if (checkedBoxes.length === 0) {
      display.classList.add('hidden');
      return;
    }

    display.classList.remove('hidden');
    list.innerHTML = Array.from(checkedBoxes).map(checkbox => {
      const type = checkbox.dataset.filterType;
      const value = checkbox.dataset.filterValue;
      return `
        <span class="px-2 py-1 bg-blue-500 text-white text-xs rounded">
          ${type}: ${value}
        </span>
      `;
    }).join('');
  },

  // Appliquer les filtres
  applyFilters() {
    const modal = document.getElementById('filtersModal');
    if (!modal) return;

    const checkedBoxes = modal.querySelectorAll('.filter-checkbox:checked');

    // Sauvegarder les filtres actifs
    this.activeFilters = {};
    checkedBoxes.forEach(checkbox => {
      const type = checkbox.dataset.filterType;
      const value = checkbox.dataset.filterValue;
      this.activeFilters[`${type}:${value}`] = { type, value };
    });

    // Appliquer le filtre sur toutes les cartes
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (!eleve) return;

      let match = true;

      if (checkedBoxes.length > 0) {
        match = Array.from(checkedBoxes).some(checkbox => {
          const type = checkbox.dataset.filterType;
          const value = checkbox.dataset.filterValue;

          switch(type) {
            case 'lv2': return eleve.lv2 === value;
            case 'opt': return eleve.opt === value;
            case 'disso': return eleve.disso === value;
            case 'asso': return eleve.asso === value;
            case 'mobilite': return eleve.mobilite === value;
            case 'scoreCOM': return eleve.scores && eleve.scores.COM == value;
            default: return false;
          }
        });
      }

      if (match) {
        card.style.opacity = '1';
        card.style.filter = 'none';
      } else {
        card.style.opacity = '0.3';
        card.style.filter = 'grayscale(1)';
      }
    });

    modal.remove();

    if (checkedBoxes.length > 0) {
      toast(`${checkedBoxes.length} filtre(s) appliqu√©(s)`, 'success');
    } else {
      toast('Tous les filtres effac√©s', 'info');
    }
  },

  // Effacer tous les filtres
  clearAllFilters() {
    this.activeFilters = {};

    document.querySelectorAll('.student-card').forEach(card => {
      card.style.opacity = '1';
      card.style.filter = 'none';
    });

    const modal = document.getElementById('filtersModal');
    if (modal) {
      modal.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = false);
      this.updateActiveFiltersDisplay(modal);
    }

    toast('Tous les filtres effac√©s', 'info');
  }
};

// 5. TEMPLATES DE GROUPES R√âUTILISABLES
// 6. HISTORIQUE D√âTAILL√â AVEC DIFF
const HistoryManager = {
  history: [],
  maxHistory: 50,

  // Sauvegarder l'√©tat actuel
  saveState() {
    const state = this.captureCurrentState();
    this.history.push({
      timestamp: new Date(),
      state: state
    });
    
    // Limiter la taille de l'historique
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
  },

  // Capturer l'√©tat actuel
  captureCurrentState() {
    const state = {};
    
    document.querySelectorAll('.class-column').forEach(col => {
      const classe = col.querySelector('.classe-name').textContent;
      state[classe] = [];
      
      col.querySelectorAll('.student-card').forEach(card => {
        const eleve = STATE.students[card.dataset.id];
        if (eleve) {
          state[classe].push(eleve.id);
        }
      });
    });
    
    return state;
  },

  // Comparer deux √©tats
  compareStates(before, after) {
    const changes = [];
    
    // Trouver les classes communes
    const allClasses = new Set([...Object.keys(before), ...Object.keys(after)]);
    
    allClasses.forEach(classe => {
      const beforeStudents = before[classe] || [];
      const afterStudents = after[classe] || [];
      
      // √âl√®ves ajout√©s
      const added = afterStudents.filter(id => !beforeStudents.includes(id));
      
      // √âl√®ves retir√©s
      const removed = beforeStudents.filter(id => !afterStudents.includes(id));
      
      if (added.length || removed.length) {
        changes.push({
          classe,
          added: added.map(id => STATE.students[id]?.nom || id),
          removed: removed.map(id => STATE.students[id]?.nom || id),
          timestamp: new Date()
        });
      }
    });
    
    return changes;
  },

  // Afficher l'historique des changements
  showHistory() {
    if (this.history.length < 2) {
      toast('Pas assez d\'historique pour comparer', 'warning');
    return;
    }
    
    const recent = this.history.slice(-5); // 5 derniers √©tats
    const changes = [];
    
    for (let i = 1; i < recent.length; i++) {
      const stateChanges = this.compareStates(recent[i-1].state, recent[i].state);
      if (stateChanges.length > 0) {
        changes.push({
          timestamp: recent[i].timestamp,
          changes: stateChanges
        });
      }
    }
    
    if (changes.length === 0) {
      toast('Aucun changement d√©tect√©', 'info');
      return;
    }
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">Historique des changements</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="space-y-4">
            ${changes.map(change => `
              <div class="border rounded p-3">
                <div class="font-semibold text-sm text-gray-600 mb-2">
                  ${change.timestamp.toLocaleString()}
                </div>
                ${change.changes.map(c => `
                  <div class="ml-4 mb-2">
                    <div class="font-medium">${c.classe}</div>
                    ${c.added.length > 0 ? `
                      <div class="text-green-600 text-sm">
                        <i class="fas fa-plus"></i> Ajout√©s: ${c.added.join(', ')}
                      </div>
                    ` : ''}
                    ${c.removed.length > 0 ? `
                      <div class="text-red-600 text-sm">
                        <i class="fas fa-minus"></i> Retir√©s: ${c.removed.join(', ')}
                      </div>
                    ` : ''}
                  </div>
                `).join('')}
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  },

  // Annuler le dernier changement
  undo() {
    if (this.history.length < 2) {
      toast('Rien √† annuler', 'warning');
      return;
    }
    
    const previousState = this.history[this.history.length - 2].state;
    this.restoreState(previousState);
    this.history.pop(); // Retirer l'√©tat actuel
    
    toast('Changement annul√©', 'success');
  },

  // Restaurer un √©tat
  restoreState(state) {
    // Cette fonction restaurerait l'√©tat pr√©c√©dent
    // Impl√©mentation complexe qui n√©cessiterait de modifier l'interface
    console.log('Restauration de l\'√©tat:', state);
  }
};

// 7. MODE SIMULATION
// ========== INT√âGRATION DES NOUVELLES FONCTIONS ==========

// Ajouter les boutons dans l'interface
// ========== CONFIGURATION DES BOUTONS AVANC√âS DANS LE MENU ACTIONS ==========
function configureAdvancedFeaturesButtons() {
  // Bouton Import Scores
  const importBtn = document.getElementById('btnImportScores');
  if (importBtn) {
    importBtn.onclick = () => {
      ScoreImporter.importScoresFromINT();
      // Fermer le menu apr√®s clic
      document.getElementById('actionsDropdown').classList.add('hidden');
    };
  }
  
  // Bouton Optimisation
  const optimizeBtn = document.getElementById('btnOptimize');
  if (optimizeBtn) {
    optimizeBtn.onclick = () => {
      OptimizerV2.applyOptimization();
      document.getElementById('actionsDropdown').classList.add('hidden');
    };
  }
  
  // Bouton Contraintes
  const constraintsBtn = document.getElementById('btnConstraints');
  if (constraintsBtn) {
    constraintsBtn.onclick = () => {
      ConstraintManager.showConstraintViolations();
      document.getElementById('actionsDropdown').classList.add('hidden');
    };
  }
  
  // Bouton Feedback en temps r√©el (dans le menu des groupes)
  document.addEventListener('click', (e) => {
    if (e.target.closest('#btnGroupFeedback')) {
      if (RealTimeFeedback) {
        const panel = document.getElementById('feedbackPanel');
        if (panel && panel.style.display === 'none') {
          RealTimeFeedback.show();
          e.target.closest('#btnGroupFeedback').innerHTML = '<i class="fas fa-chart-line"></i> Masquer';
        } else {
          RealTimeFeedback.hide();
          e.target.closest('#btnGroupFeedback').innerHTML = '<i class="fas fa-chart-line"></i> Indicateurs';
        }
      }
    }
    
    // Bouton Statistiques des groupes
    if (e.target.closest('#btnGroupStats')) {
      const statsPanel = document.getElementById('statsPanel');
      if (statsPanel) {
        // Basculer l'affichage du panneau de statistiques
        if (statsPanel.classList.contains('translate-x-full')) {
          statsPanel.classList.remove('translate-x-full');
          
          // Initialiser le contenu seulement si pas encore fait
          const statsContent = document.getElementById('statsContent');
          if (!statsContent.innerHTML.trim()) {
            console.log('üìä Premi√®re ouverture - initialisation du contenu');
            if (typeof initCharts === 'function') {
              initCharts();
            }
          }
          
          // MISE √Ä JOUR INTELLIGENTE DES STATISTIQUES
          if (typeof updateStatsPanel === 'function') {
            updateStatsPanel();
          }
          
          // Changer le titre pour indiquer qu'on affiche les stats des groupes
          const title = statsPanel.querySelector('h2');
          if (title) {
            title.textContent = 'Statistiques des Groupes';
          }
        } else {
          statsPanel.classList.add('translate-x-full');
        }
      }
    }
  });
}

// ========== INITIALISATION AU CHARGEMENT ==========

// Ajouter au DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialiser le feedback en temps r√©el (mais ne pas l'afficher automatiquement)
  setTimeout(() => {
    if (RealTimeFeedback) {
      RealTimeFeedback.init();
    }
  }, 500);
  
  // Configurer les boutons avanc√©s dans le menu Actions apr√®s un d√©lai
  setTimeout(() => {
    configureAdvancedFeaturesButtons();
  }, 2000);
  
  // Configurer le bouton de fermeture du panneau des statistiques
  const closeStatsBtn = document.getElementById('closeStats');
  if (closeStatsBtn) {
    closeStatsBtn.addEventListener('click', () => {
      const statsPanel = document.getElementById('statsPanel');
      if (statsPanel) {
        statsPanel.classList.add('translate-x-full');
        // Mettre √† jour aria-expanded
        const btnStats = document.getElementById('btnStats');
        if (btnStats) btnStats.setAttribute('aria-expanded', 'false');
        console.log('üìä Panneau des statistiques ferm√© manuellement');

      }
    });
  }

  // Sauvegarder l'√©tat initial
  setTimeout(() => {
    HistoryManager.saveState();
  }, 3000);
});

// Fonction pour initialiser les groupes apr√®s fermeture du modal
window.initializeGroupsAfterModal = function() {
  // Ajouter le bouton Groupes
  addGroupsButton();
  
  // Charger les groupes sauvegard√©s SANS les afficher
  if (GroupManager && GroupManager.loadGroups) {
    GroupManager.loadGroups();
    
    // Mettre √† jour le bouton pour afficher le nombre
    if (GroupManager.updateGroupsButton) {
      GroupManager.updateGroupsButton();
    }
  }
};

console.log('‚úÖ Module de groupes et am√©liorations V2 appliqu√©s');

// ========== PATCH CORRECTIF POUR STATISTIQUES FLUIDES ==========
// (ANCIENNE VERSION SUPPRIM√âE - REMPLAC√âE PAR LA VERSION PROT√âG√âE)

// 2. ANCIENNE VERSION DE updateAllColumnStats SUPPRIM√âE - REMPLAC√âE PAR LA VERSION PROPRE

// 3. SUPPRIM√â - Red√©finition probl√©matique de updateCharts
// La vraie fonction updateCharts est maintenant utilis√©e directement

// 4. Am√©liorer le feedback en temps r√©el avec throttle
if (window.RealTimeFeedback) {
  const originalUpdateMetrics = RealTimeFeedback.updateMetrics;
  let lastUpdate = 0;
  const THROTTLE_DELAY = 500; // Mise √† jour max toutes les 500ms
  
  RealTimeFeedback.updateMetrics = function() {
    const now = Date.now();
    if (now - lastUpdate < THROTTLE_DELAY) {
      return;
    }
    lastUpdate = now;
    
    if (originalUpdateMetrics) {
      originalUpdateMetrics.call(this);
    }
  };
}

// 5. ANCIENNE VERSION DE handleSortEnd SUPPRIM√âE - REMPLAC√âE PAR LA VERSION PROPRE

// 6. CSS pour animations fluides (√† ajouter dans une balise style)
const fluidStyles = document.createElement('style');
fluidStyles.textContent = `
  /* Animation fluide pour le panneau stats */
  #statsPanel {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                opacity 0.3s ease;
  }
  
  #statsPanel.updating {
    opacity: 0.95;
  }
  
  /* Transition fluide pour les graphiques */
  .chart-container {
    transition: opacity 0.2s ease;
  }
  
  .stats-panel.updating .chart-container {
    opacity: 0.8;
  }
  
  /* Emp√™cher le scintillement des m√©triques */
  .metric-value {
    transition: color 0.2s ease, transform 0.2s ease;
  }
  
  .metric-value.changed {
    transform: scale(1.05);
  }
  
  /* Animation subtile pour les mises √† jour */
  @keyframes gentlePulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.9; }
  }
  
  .stats-panel.updating {
    animation: gentlePulse 0.6s ease-in-out;
  }
`;
document.head.appendChild(fluidStyles);

// 7. Fonction utilitaire pour v√©rifier l'√©tat des graphiques
window.areChartsReady = function() {
  return window.chartCommunication && 
         window.chartDistribution && 
         window.chartLV2 && 
         window.chartOptions &&
         typeof window.chartCommunication.update === 'function';
};

// 8. Optimiser le rendu des cartes √©l√®ves
window.optimizeCardRendering = function() {
  // Utiliser requestAnimationFrame pour les mises √† jour visuelles
  const cards = document.querySelectorAll('.student-card');
  let index = 0;
  
  function processNextBatch() {
    const batchSize = 10;
    const batch = Array.from(cards).slice(index, index + batchSize);
    
    batch.forEach(card => {
      // Appliquer les optimisations de rendu
      card.style.willChange = 'transform';
      card.style.backfaceVisibility = 'hidden';
    });
    
    index += batchSize;
    
    if (index < cards.length) {
      requestAnimationFrame(processNextBatch);
    }
  }
  
  requestAnimationFrame(processNextBatch);
};

// 9. Nettoyer les fonctions dupliqu√©es au chargement
document.addEventListener('DOMContentLoaded', () => {
  // Supprimer les event listeners dupliqu√©s
  const processedElements = new Set();
  
  document.querySelectorAll('[id]').forEach(element => {
    if (processedElements.has(element.id)) {
      console.warn(`√âl√©ment dupliqu√© d√©tect√©: ${element.id}`);
      return;
    }
    processedElements.add(element.id);
  });
  
  // Optimiser le rendu initial
  setTimeout(optimizeCardRendering, 1000);
});

console.log('‚úÖ Patch de fluidit√© des statistiques appliqu√©');

// ========== CORRECTIONS FINALES SUPPL√âMENTAIRES ==========

// 1. Initialisation s√©curis√©e des variables globales manquantes
if (typeof window.chartLV2Details === 'undefined') {
  window.chartLV2Details = null;
}

// 2. Fonction utilitaire pour mise √† jour s√©curis√©e des graphiques
window.safeUpdateChart = function(chart) {
  if (chart && typeof chart.update === 'function') {
    try {
      chart.update('none'); // Mise √† jour sans animation pour plus de fluidit√©
    } catch (error) {
      console.warn('Erreur mise √† jour graphique:', error);
    }
  }
};

// 3. Syst√®me de gestion des event listeners pour √©viter les doublons
window.EventManager = {
  listeners: [],
  
  add: function(element, event, handler, options = {}) {
    // V√©rifier si le listener existe d√©j√†
    const existing = this.listeners.find(l => 
      l.element === element && l.event === event && l.handler === handler
    );
    
    if (!existing) {
      element.addEventListener(event, handler, options);
      this.listeners.push({element, event, handler, options});
    }
  },
  
  remove: function(element, event, handler) {
    element.removeEventListener(event, handler);
    this.listeners = this.listeners.filter(l => 
      !(l.element === element && l.event === event && l.handler === handler)
    );
  },
  
  clear: function() {
    this.listeners.forEach(({element, event, handler}) => {
      element.removeEventListener(event, handler);
    });
    this.listeners = [];
  }
};

// 4. Initialisation unique de l'application
window.addEventListener('DOMContentLoaded', () => {
  // √âviter les initialisations multiples
  if (window._initialized) {
    console.log('‚ö†Ô∏è Application d√©j√† initialis√©e, skip');
    return;
  }
  window._initialized = true;
  
  console.log('üöÄ Initialisation unique de l\'application');
  
  // Nettoyer les anciens event listeners
  if (window.EventManager) {
    window.EventManager.clear();
  }
  
  // Attendre que tout soit charg√©
  setTimeout(() => {
    if (typeof initRepartitionApp === 'function') {
      initRepartitionApp();
    }
  }, 100);
});

// 5. CSS pour transitions fluides (si pas d√©j√† pr√©sent)
if (!document.getElementById('fluid-animations-style')) {
  const style = document.createElement('style');
  style.id = 'fluid-animations-style';
  style.textContent = `
    .stats-panel {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .student-card {
      transition: all 0.2s ease;
      will-change: transform;
    }
    
    .chart-container {
      transition: opacity 0.3s ease;
    }
    
    /* Am√©lioration des animations de drag & drop */
    .sortable-ghost {
      opacity: 0.5;
      transform: rotate(5deg);
    }
    
    .sortable-chosen {
      transform: scale(1.05);
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }
    
    /* Animation pour les mises √† jour de statistiques */
    .stats-updating {
      animation: gentlePulse 0.6s ease-in-out;
    }
    
    @keyframes gentlePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.9; }
    }
  `;
  document.head.appendChild(style);
}

// ========== ANCIENNES VERSIONS SUPPRIM√âES - REMPLAC√âES PAR LA VERSION PROPRE ==========
// Toutes les anciennes versions de updateStatsPanel et les protections excessives ont √©t√© supprim√©es
// et remplac√©es par la version propre ajout√©e √† la fin du fichier
</script>
